[
    {
        "repo": "mwaskom/seaborn",
        "instance_id": "mwaskom__seaborn-2848",
        "base_commit": "94621cef29f80282436d73e8d2c0aa76dab81273",
        "patch": "diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -149,6 +149,13 @@ def _lookup_single(self, key):\n             # Use a value that's in the original data vector\n             value = self.lookup_table[key]\n         except KeyError:\n+\n+            if self.norm is None:\n+                # Currently we only get here in scatterplot with hue_order,\n+                # because scatterplot does not consider hue a grouping variable\n+                # So unused hue levels are in the data, but not the lookup table\n+                return (0, 0, 0, 0)\n+\n             # Use the colormap to interpolate between existing datapoints\n             # (e.g. in the context of making a continuous legend)\n             try:\n",
        "test_patch": "diff --git a/tests/test_relational.py b/tests/test_relational.py\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -9,6 +9,7 @@\n \n from seaborn.external.version import Version\n from seaborn.palettes import color_palette\n+from seaborn._oldcore import categorical_order\n \n from seaborn.relational import (\n     _RelationalPlotter,\n@@ -1623,6 +1624,16 @@ def test_supplied_color_array(self, long_df):\n         _draw_figure(ax.figure)\n         assert_array_equal(ax.collections[0].get_facecolors(), colors)\n \n+    def test_hue_order(self, long_df):\n+\n+        order = categorical_order(long_df[\"a\"])\n+        unused = order.pop()\n+\n+        ax = scatterplot(data=long_df, x=\"x\", y=\"y\", hue=\"a\", hue_order=order)\n+        points = ax.collections[0]\n+        assert (points.get_facecolors()[long_df[\"a\"] == unused] == 0).all()\n+        assert [t.get_text() for t in ax.legend_.texts] == order\n+\n     def test_linewidths(self, long_df):\n \n         f, ax = plt.subplots()\n",
        "problem_statement": "PairGrid errors with `hue` assigned in `map`\nIn seaborn version 0.9.0 I was able to use the following Code to plot scatterplots across a PairGrid with categorical hue. The reason I am not using the \"hue\" keyword in creating the PairGrid is, that I want one regression line (with regplot) and not one regression per hue-category.\r\n```python\r\nimport seaborn as sns\r\niris = sns.load_dataset(\"iris\")\r\ng = sns.PairGrid(iris, y_vars=[\"sepal_length\",\"sepal_width\"], x_vars=[\"petal_length\",\"petal_width\"])\r\ng.map(sns.scatterplot, hue=iris[\"species\"])\r\ng.map(sns.regplot, scatter=False)\r\n```\r\n\r\nHowever, since I updated to searbon 0.11.1 the following Error message occurs:\r\n```\r\n---------------------------------------------------------------------------\r\nKeyError                                  Traceback (most recent call last)\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in _lookup_single(self, key)\r\n    143             # Use a value that's in the original data vector\r\n--> 144             value = self.lookup_table[key]\r\n    145         except KeyError:\r\n\r\nKeyError: 'setosa'\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTypeError                                 Traceback (most recent call last)\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in _lookup_single(self, key)\r\n    148             try:\r\n--> 149                 normed = self.norm(key)\r\n    150             except TypeError as err:\r\n\r\nTypeError: 'NoneType' object is not callable\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-3-46dd21e9c95a> in <module>\r\n      2 iris = sns.load_dataset(\"iris\")\r\n      3 g = sns.PairGrid(iris, y_vars=[\"sepal_length\",\"sepal_width\"], x_vars=[\"petal_length\",\"species\"])\r\n----> 4 g.map(sns.scatterplot, hue=iris[\"species\"])\r\n      5 \r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/axisgrid.py in map(self, func, **kwargs)\r\n   1263         row_indices, col_indices = np.indices(self.axes.shape)\r\n   1264         indices = zip(row_indices.flat, col_indices.flat)\r\n-> 1265         self._map_bivariate(func, indices, **kwargs)\r\n   1266 \r\n   1267         return self\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/axisgrid.py in _map_bivariate(self, func, indices, **kwargs)\r\n   1463             if ax is None:  # i.e. we are in corner mode\r\n   1464                 continue\r\n-> 1465             self._plot_bivariate(x_var, y_var, ax, func, **kws)\r\n   1466         self._add_axis_labels()\r\n   1467 \r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/axisgrid.py in _plot_bivariate(self, x_var, y_var, ax, func, **kwargs)\r\n   1503         kwargs.setdefault(\"hue_order\", self._hue_order)\r\n   1504         kwargs.setdefault(\"palette\", self._orig_palette)\r\n-> 1505         func(x=x, y=y, **kwargs)\r\n   1506 \r\n   1507         self._update_legend_data(ax)\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_decorators.py in inner_f(*args, **kwargs)\r\n     44             )\r\n     45         kwargs.update({k: arg for k, arg in zip(sig.parameters, args)})\r\n---> 46         return f(**kwargs)\r\n     47     return inner_f\r\n     48 \r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/relational.py in scatterplot(x, y, hue, style, size, data, palette, hue_order, hue_norm, sizes, size_order, size_norm, markers, style_order, x_bins, y_bins, units, estimator, ci, n_boot, alpha, x_jitter, y_jitter, legend, ax, **kwargs)\r\n    818     p._attach(ax)\r\n    819 \r\n--> 820     p.plot(ax, kwargs)\r\n    821 \r\n    822     return ax\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/relational.py in plot(self, ax, kws)\r\n    626         # Apply the mapping from semantic variables to artist attributes\r\n    627         if \"hue\" in self.variables:\r\n--> 628             c = self._hue_map(data[\"hue\"])\r\n    629 \r\n    630         if \"size\" in self.variables:\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in __call__(self, key, *args, **kwargs)\r\n     61         \"\"\"Get the attribute(s) values for the data key.\"\"\"\r\n     62         if isinstance(key, (list, np.ndarray, pd.Series)):\r\n---> 63             return [self._lookup_single(k, *args, **kwargs) for k in key]\r\n     64         else:\r\n     65             return self._lookup_single(key, *args, **kwargs)\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in <listcomp>(.0)\r\n     61         \"\"\"Get the attribute(s) values for the data key.\"\"\"\r\n     62         if isinstance(key, (list, np.ndarray, pd.Series)):\r\n---> 63             return [self._lookup_single(k, *args, **kwargs) for k in key]\r\n     64         else:\r\n     65             return self._lookup_single(key, *args, **kwargs)\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in _lookup_single(self, key)\r\n    149                 normed = self.norm(key)\r\n    150             except TypeError as err:\r\n--> 151                 if np.isnan(key):\r\n    152                     value = (0, 0, 0, 0)\r\n    153                 else:\r\n\r\nTypeError: ufunc 'isnan' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''\r\n```\r\n\r\nMy further observations are:\r\n- the error does not occur when using the \"hue\" keyword when creating PairGrid\r\n- the error does not occur for numerical values for hue\r\n- changing the dtype to \"categorical\" does not help\r\n\r\nEdit:\r\nI tried all versions between 0.9.0 and the current release (0.11.1) and the error only occurs in the current release. If I use 0.11.0, the plot seems to work.\n",
        "hints_text": "The following workarounds seem to work:\r\n```\r\ng.map(sns.scatterplot, hue=iris[\"species\"], hue_order=iris[\"species\"].unique())\r\n```\r\nor\r\n```\r\ng.map(lambda x, y, **kwargs: sns.scatterplot(x=x, y=y, hue=iris[\"species\"]))\r\n```\n> ```\r\n> g.map(sns.scatterplot, hue=iris[\"species\"], hue_order=iris[\"species\"].unique())\r\n> ```\r\n\r\nThe workaround fixes the problem for me.\r\nThank you very much!\r\n\r\n@mwaskom Should I close the Issue or leave it open until the bug is fixed?\nThat's a good workaround, but it's still a bug. The problem is that `PairGrid` now lets `hue` at the grid-level delegate to the axes-level functions if they have `hue` in their signature. But it's not properly handling the case where `hue` is *not* set for the grid, but *is* specified for one mapped function. @jhncls's workaround suggests the fix.\r\n\r\nAn easier workaround would have been to set `PairGrid(..., hue=\"species\")` and then pass `.map(..., hue=None)` where you don't want to separate by species. But `regplot` is the one axis-level function that does not yet handle hue-mapping internally, so it doesn't work for this specific case. It would have if you wanted a single bivariate density over hue-mapped scatterplot points (i.e. [this example](http://seaborn.pydata.org/introduction.html#classes-and-functions-for-making-complex-graphics) or something similar.",
        "created_at": "2022-06-11T18:21:32Z",
        "version": "0.12",
        "FAIL_TO_PASS": "[\"tests/test_relational.py::TestScatterPlotter::test_hue_order\"]",
        "PASS_TO_PASS": "[\"tests/test_relational.py::TestRelationalPlotter::test_wide_df_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_df_with_nonnumeric_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_array_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_flat_array_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_flat_list_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_flat_series_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_list_of_series_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_list_of_arrays_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_list_of_list_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_dict_of_series_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_dict_of_arrays_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_dict_of_lists_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_complex\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_vectors[series]\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_vectors[numpy]\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_vectors[list]\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_wide\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_hues\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_sizes\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_styles\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_stringy_numerics\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_data\", \"tests/test_relational.py::TestRelationalPlotter::test_facet_variable_collision\", \"tests/test_relational.py::TestRelationalPlotter::test_ax_kwarg_removal\", \"tests/test_relational.py::TestLinePlotter::test_legend_data\", \"tests/test_relational.py::TestLinePlotter::test_plot\", \"tests/test_relational.py::TestLinePlotter::test_axis_labels\", \"tests/test_relational.py::TestScatterPlotter::test_color\", \"tests/test_relational.py::TestScatterPlotter::test_legend_data\", \"tests/test_relational.py::TestScatterPlotter::test_plot\", \"tests/test_relational.py::TestScatterPlotter::test_axis_labels\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_axes\", \"tests/test_relational.py::TestScatterPlotter::test_literal_attribute_vectors\", \"tests/test_relational.py::TestScatterPlotter::test_supplied_color_array\", \"tests/test_relational.py::TestScatterPlotter::test_linewidths\", \"tests/test_relational.py::TestScatterPlotter::test_size_norm_extrapolation\", \"tests/test_relational.py::TestScatterPlotter::test_datetime_scale\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics0]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics1]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics2]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics3]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics4]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics5]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics6]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics7]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics8]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics9]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics10]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics11]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_smoke\"]",
        "environment_setup_commit": "d25872b0fc99dbf7e666a91f59bd4ed125186aa1",
        "issue_title": "PairGrid errors with `hue` assigned in `map`",
        "test_file": "/home/fdse/wy/RepoCodeEdit/data/raw_repo_lite/seaborn/tests/test_axisgrid.py",
        "searched_functions": [
            "def test_remove_hue_from_default(self):\n\n        hue = \"z\"\n        g = ag.PairGrid(self.df, hue=hue)\n        assert hue not in g.x_vars\n        assert hue not in g.y_vars\n\n        vars = [\"x\", \"y\", \"z\"]\n        g = ag.PairGrid(self.df, hue=hue, vars=vars)\n        assert hue in g.x_vars\n        assert hue in g.y_vars",
            "def test_hue_order_missing_level(self):\n\n        order = list(\"dcaeb\")\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map(plt.plot)\n\n        for line, level in zip(g.axes[1, 0].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"x\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"y\"])\n\n        plt.close(\"all\")\n\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map_diag(plt.plot)\n\n        for line, level in zip(g.axes[0, 0].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"x\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"x\"])\n\n        plt.close(\"all\")\n\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map_lower(plt.plot)\n\n        for line, level in zip(g.axes[1, 0].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"x\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"y\"])\n\n        plt.close(\"all\")\n\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map_upper(plt.plot)\n\n        for line, level in zip(g.axes[0, 1].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"y\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"x\"])\n\n        plt.close(\"all\")",
            "def test_hue_order(self):\n\n        order = list(\"dcab\")\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map(plt.plot)\n\n        for line, level in zip(g.axes[1, 0].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"x\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"y\"])\n\n        plt.close(\"all\")\n\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map_diag(plt.plot)\n\n        for line, level in zip(g.axes[0, 0].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"x\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"x\"])\n\n        plt.close(\"all\")\n\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map_lower(plt.plot)\n\n        for line, level in zip(g.axes[1, 0].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"x\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"y\"])\n\n        plt.close(\"all\")\n\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map_upper(plt.plot)\n\n        for line, level in zip(g.axes[0, 1].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"y\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"x\"])\n\n        plt.close(\"all\")",
            "def test_map(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\", hue=\"c\")\n        g.map(plt.plot, \"x\", \"y\", linewidth=3)\n\n        lines = g.axes[0, 0].lines\n        assert len(lines) == 3\n\n        line1, _, _ = lines\n        assert line1.get_linewidth() == 3\n        x, y = line1.get_data()\n        mask = (self.df.a == \"a\") & (self.df.b == \"m\") & (self.df.c == \"t\")\n        npt.assert_array_equal(x, self.df.x[mask])\n        npt.assert_array_equal(y, self.df.y[mask])",
            "def test_hue_in_map(self, long_df):\n\n        g = ag.PairGrid(long_df, vars=[\"x\", \"y\"])\n        g.map(scatterplot, hue=long_df[\"a\"])\n        ax = g.axes.flat[0]\n        points = ax.collections[0]\n        assert len(set(map(tuple, points.get_facecolors()))) == 3",
            "def test_map(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        g1 = ag.PairGrid(self.df)\n        g1.map(plt.scatter)\n\n        for i, axes_i in enumerate(g1.axes):\n            for j, ax in enumerate(axes_i):\n                x_in = self.df[vars[j]]\n                y_in = self.df[vars[i]]\n                x_out, y_out = ax.collections[0].get_offsets().T\n                npt.assert_array_equal(x_in, x_out)\n                npt.assert_array_equal(y_in, y_out)\n\n        g2 = ag.PairGrid(self.df, hue=\"a\")\n        g2.map(plt.scatter)\n\n        for i, axes_i in enumerate(g2.axes):\n            for j, ax in enumerate(axes_i):\n                x_in = self.df[vars[j]]\n                y_in = self.df[vars[i]]\n                for k, k_level in enumerate(self.df.a.unique()):\n                    x_in_k = x_in[self.df.a == k_level]\n                    y_in_k = y_in[self.df.a == k_level]\n                    x_out, y_out = ax.collections[k].get_offsets().T\n                npt.assert_array_equal(x_in_k, x_out)\n                npt.assert_array_equal(y_in_k, y_out)",
            "def test_map_diag(self):\n\n        g = ag.PairGrid(self.df)\n        g.map_diag(plt.hist)\n\n        for var, ax in zip(g.diag_vars, g.diag_axes):\n            assert len(ax.patches) == 10\n            assert pytest.approx(ax.patches[0].get_x()) == self.df[var].min()\n\n        g = ag.PairGrid(self.df, hue=\"a\")\n        g.map_diag(plt.hist)\n\n        for ax in g.diag_axes:\n            assert len(ax.patches) == 30\n\n        g = ag.PairGrid(self.df, hue=\"a\")\n        g.map_diag(plt.hist, histtype='step')\n\n        for ax in g.diag_axes:\n            for ptch in ax.patches:\n                assert not ptch.fill",
            "def test_map_diag_rectangular(self):\n\n        x_vars = [\"x\", \"y\"]\n        y_vars = [\"x\", \"z\", \"y\"]\n        g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n        g1.map_diag(plt.hist)\n        g1.map_offdiag(plt.scatter)\n\n        assert set(g1.diag_vars) == (set(x_vars) & set(y_vars))\n\n        for var, ax in zip(g1.diag_vars, g1.diag_axes):\n            assert len(ax.patches) == 10\n            assert pytest.approx(ax.patches[0].get_x()) == self.df[var].min()\n\n        for j, x_var in enumerate(x_vars):\n            for i, y_var in enumerate(y_vars):\n\n                ax = g1.axes[i, j]\n                if x_var == y_var:\n                    diag_ax = g1.diag_axes[j]  # because fewer x than y vars\n                    assert ax.bbox.bounds == diag_ax.bbox.bounds\n\n                else:\n                    x, y = ax.collections[0].get_offsets().T\n                    assert_array_equal(x, self.df[x_var])\n                    assert_array_equal(y, self.df[y_var])\n\n        g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue=\"a\")\n        g2.map_diag(plt.hist)\n        g2.map_offdiag(plt.scatter)\n\n        assert set(g2.diag_vars) == (set(x_vars) & set(y_vars))\n\n        for ax in g2.diag_axes:\n            assert len(ax.patches) == 30\n\n        x_vars = [\"x\", \"y\", \"z\"]\n        y_vars = [\"x\", \"z\"]\n        g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n        g3.map_diag(plt.hist)\n        g3.map_offdiag(plt.scatter)\n\n        assert set(g3.diag_vars) == (set(x_vars) & set(y_vars))\n\n        for var, ax in zip(g3.diag_vars, g3.diag_axes):\n            assert len(ax.patches) == 10\n            assert pytest.approx(ax.patches[0].get_x()) == self.df[var].min()\n\n        for j, x_var in enumerate(x_vars):\n            for i, y_var in enumerate(y_vars):\n\n                ax = g3.axes[i, j]\n                if x_var == y_var:\n                    diag_ax = g3.diag_axes[i]  # because fewer y than x vars\n                    assert ax.bbox.bounds == diag_ax.bbox.bounds\n                else:\n                    x, y = ax.collections[0].get_offsets().T\n                    assert_array_equal(x, self.df[x_var])\n                    assert_array_equal(y, self.df[y_var])",
            "def test_hue(self, long_df, as_vector):\n\n        if as_vector:\n            data = None\n            x, y, hue = long_df[\"x\"], long_df[\"y\"], long_df[\"a\"]\n        else:\n            data = long_df\n            x, y, hue = \"x\", \"y\", \"a\"\n\n        g = ag.JointGrid(data=data, x=x, y=y, hue=hue)\n        g.plot_joint(scatterplot)\n        g.plot_marginals(histplot)\n\n        g2 = ag.JointGrid()\n        scatterplot(data=long_df, x=x, y=y, hue=hue, ax=g2.ax_joint)\n        histplot(data=long_df, x=x, hue=hue, ax=g2.ax_marg_x)\n        histplot(data=long_df, y=y, hue=hue, ax=g2.ax_marg_y)\n\n        assert_plots_equal(g.ax_joint, g2.ax_joint)\n        assert_plots_equal(g.ax_marg_x, g2.ax_marg_x, labels=False)\n        assert_plots_equal(g.ax_marg_y, g2.ax_marg_y, labels=False)",
            "def test_map_nonsquare(self):\n\n        x_vars = [\"x\"]\n        y_vars = [\"y\", \"z\"]\n        g = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n        g.map(plt.scatter)\n\n        x_in = self.df.x\n        for i, i_var in enumerate(y_vars):\n            ax = g.axes[i, 0]\n            y_in = self.df[i_var]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)"
        ]
    },
    {
        "repo": "mwaskom/seaborn",
        "instance_id": "mwaskom__seaborn-3010",
        "base_commit": "0f5a013e2cf43562deec3b879458e59a73853813",
        "patch": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -38,7 +38,10 @@ def _fit_predict(self, data):\n \n     def __call__(self, data, groupby, orient, scales):\n \n-        return groupby.apply(data, self._fit_predict)\n+        return (\n+            groupby\n+            .apply(data.dropna(subset=[\"x\", \"y\"]), self._fit_predict)\n+        )\n \n \n @dataclass\n",
        "test_patch": "diff --git a/tests/_stats/test_regression.py b/tests/_stats/test_regression.py\n--- a/tests/_stats/test_regression.py\n+++ b/tests/_stats/test_regression.py\n@@ -4,6 +4,7 @@\n \n import pytest\n from numpy.testing import assert_array_equal, assert_array_almost_equal\n+from pandas.testing import assert_frame_equal\n \n from seaborn._core.groupby import GroupBy\n from seaborn._stats.regression import PolyFit\n@@ -50,3 +51,11 @@ def test_one_grouper(self, df):\n             grid = np.linspace(part[\"x\"].min(), part[\"x\"].max(), gridsize)\n             assert_array_equal(part[\"x\"], grid)\n             assert part[\"y\"].diff().diff().dropna().abs().gt(0).all()\n+\n+    def test_missing_data(self, df):\n+\n+        groupby = GroupBy([\"group\"])\n+        df.iloc[5:10] = np.nan\n+        res1 = PolyFit()(df[[\"x\", \"y\"]], groupby, \"x\", {})\n+        res2 = PolyFit()(df[[\"x\", \"y\"]].dropna(), groupby, \"x\", {})\n+        assert_frame_equal(res1, res2)\n\\ No newline at end of file\n",
        "problem_statement": "PolyFit is not robust to missing data\n```python\r\nso.Plot([1, 2, 3, None, 4], [1, 2, 3, 4, 5]).add(so.Line(), so.PolyFit())\r\n```\r\n\r\n<details><summary>Traceback</summary>\r\n\r\n```python-traceback\r\n---------------------------------------------------------------------------\r\nLinAlgError                               Traceback (most recent call last)\r\nFile ~/miniconda3/envs/seaborn-py39-latest/lib/python3.9/site-packages/IPython/core/formatters.py:343, in BaseFormatter.__call__(self, obj)\r\n    341     method = get_real_method(obj, self.print_method)\r\n    342     if method is not None:\r\n--> 343         return method()\r\n    344     return None\r\n    345 else:\r\n\r\nFile ~/code/seaborn/seaborn/_core/plot.py:265, in Plot._repr_png_(self)\r\n    263 def _repr_png_(self) -> tuple[bytes, dict[str, float]]:\r\n--> 265     return self.plot()._repr_png_()\r\n\r\nFile ~/code/seaborn/seaborn/_core/plot.py:804, in Plot.plot(self, pyplot)\r\n    800 \"\"\"\r\n    801 Compile the plot spec and return the Plotter object.\r\n    802 \"\"\"\r\n    803 with theme_context(self._theme_with_defaults()):\r\n--> 804     return self._plot(pyplot)\r\n\r\nFile ~/code/seaborn/seaborn/_core/plot.py:822, in Plot._plot(self, pyplot)\r\n    819 plotter._setup_scales(self, common, layers, coord_vars)\r\n    821 # Apply statistical transform(s)\r\n--> 822 plotter._compute_stats(self, layers)\r\n    824 # Process scale spec for semantic variables and coordinates computed by stat\r\n    825 plotter._setup_scales(self, common, layers)\r\n\r\nFile ~/code/seaborn/seaborn/_core/plot.py:1110, in Plotter._compute_stats(self, spec, layers)\r\n   1108     grouper = grouping_vars\r\n   1109 groupby = GroupBy(grouper)\r\n-> 1110 res = stat(df, groupby, orient, scales)\r\n   1112 if pair_vars:\r\n   1113     data.frames[coord_vars] = res\r\n\r\nFile ~/code/seaborn/seaborn/_stats/regression.py:41, in PolyFit.__call__(self, data, groupby, orient, scales)\r\n     39 def __call__(self, data, groupby, orient, scales):\r\n---> 41     return groupby.apply(data, self._fit_predict)\r\n\r\nFile ~/code/seaborn/seaborn/_core/groupby.py:109, in GroupBy.apply(self, data, func, *args, **kwargs)\r\n    106 grouper, groups = self._get_groups(data)\r\n    108 if not grouper:\r\n--> 109     return self._reorder_columns(func(data, *args, **kwargs), data)\r\n    111 parts = {}\r\n    112 for key, part_df in data.groupby(grouper, sort=False):\r\n\r\nFile ~/code/seaborn/seaborn/_stats/regression.py:30, in PolyFit._fit_predict(self, data)\r\n     28     xx = yy = []\r\n     29 else:\r\n---> 30     p = np.polyfit(x, y, self.order)\r\n     31     xx = np.linspace(x.min(), x.max(), self.gridsize)\r\n     32     yy = np.polyval(p, xx)\r\n\r\nFile <__array_function__ internals>:180, in polyfit(*args, **kwargs)\r\n\r\nFile ~/miniconda3/envs/seaborn-py39-latest/lib/python3.9/site-packages/numpy/lib/polynomial.py:668, in polyfit(x, y, deg, rcond, full, w, cov)\r\n    666 scale = NX.sqrt((lhs*lhs).sum(axis=0))\r\n    667 lhs /= scale\r\n--> 668 c, resids, rank, s = lstsq(lhs, rhs, rcond)\r\n    669 c = (c.T/scale).T  # broadcast scale coefficients\r\n    671 # warn on rank reduction, which indicates an ill conditioned matrix\r\n\r\nFile <__array_function__ internals>:180, in lstsq(*args, **kwargs)\r\n\r\nFile ~/miniconda3/envs/seaborn-py39-latest/lib/python3.9/site-packages/numpy/linalg/linalg.py:2300, in lstsq(a, b, rcond)\r\n   2297 if n_rhs == 0:\r\n   2298     # lapack can't handle n_rhs = 0 - so allocate the array one larger in that axis\r\n   2299     b = zeros(b.shape[:-2] + (m, n_rhs + 1), dtype=b.dtype)\r\n-> 2300 x, resids, rank, s = gufunc(a, b, rcond, signature=signature, extobj=extobj)\r\n   2301 if m == 0:\r\n   2302     x[...] = 0\r\n\r\nFile ~/miniconda3/envs/seaborn-py39-latest/lib/python3.9/site-packages/numpy/linalg/linalg.py:101, in _raise_linalgerror_lstsq(err, flag)\r\n    100 def _raise_linalgerror_lstsq(err, flag):\r\n--> 101     raise LinAlgError(\"SVD did not converge in Linear Least Squares\")\r\n\r\nLinAlgError: SVD did not converge in Linear Least Squares\r\n\r\n```\r\n\r\n</details>\n",
        "hints_text": "",
        "created_at": "2022-09-11T19:37:32Z",
        "version": "0.12",
        "FAIL_TO_PASS": "[\"tests/_stats/test_regression.py::TestPolyFit::test_missing_data\"]",
        "PASS_TO_PASS": "[\"tests/_stats/test_regression.py::TestPolyFit::test_no_grouper\", \"tests/_stats/test_regression.py::TestPolyFit::test_one_grouper\"]",
        "environment_setup_commit": "d25872b0fc99dbf7e666a91f59bd4ed125186aa1",
        "issue_title": "PolyFit is not robust to missing data",
        "test_file": "/home/fdse/wy/RepoCodeEdit/data/raw_repo_lite/seaborn/tests/_stats/test_regression.py",
        "searched_functions": [
            "def test_no_grouper(self, df):\n\n        groupby = GroupBy([\"group\"])\n        res = PolyFit(order=1, gridsize=100)(df[[\"x\", \"y\"]], groupby, \"x\", {})\n\n        assert_array_equal(res.columns, [\"x\", \"y\"])\n\n        grid = np.linspace(df[\"x\"].min(), df[\"x\"].max(), 100)\n        assert_array_equal(res[\"x\"], grid)\n        assert_array_almost_equal(\n            res[\"y\"].diff().diff().dropna(), np.zeros(grid.size - 2)\n        )",
            "def test_one_grouper(self, df):\n\n        groupby = GroupBy([\"group\"])\n        gridsize = 50\n        res = PolyFit(gridsize=gridsize)(df, groupby, \"x\", {})\n\n        assert res.columns.to_list() == [\"x\", \"y\", \"group\"]\n\n        ngroups = df[\"group\"].nunique()\n        assert_array_equal(res.index, np.arange(ngroups * gridsize))\n\n        for _, part in res.groupby(\"group\"):\n            grid = np.linspace(part[\"x\"].min(), part[\"x\"].max(), gridsize)\n            assert_array_equal(part[\"x\"], grid)\n            assert part[\"y\"].diff().diff().dropna().abs().gt(0).all()",
            "def df(self, rng):\n\n        n = 100\n        return pd.DataFrame(dict(\n            x=rng.normal(0, 1, n),\n            y=rng.normal(0, 1, n),\n            color=rng.choice([\"a\", \"b\", \"c\"], n),\n            group=rng.choice([\"x\", \"y\"], n),\n        ))"
        ]
    },
    {
        "repo": "mwaskom/seaborn",
        "instance_id": "mwaskom__seaborn-3190",
        "base_commit": "4a9e54962a29c12a8b103d75f838e0e795a6974d",
        "patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -346,7 +346,7 @@ def _setup(\n                 vmin, vmax = data.min(), data.max()\n             else:\n                 vmin, vmax = new.norm\n-            vmin, vmax = axis.convert_units((vmin, vmax))\n+            vmin, vmax = map(float, axis.convert_units((vmin, vmax)))\n             a = forward(vmin)\n             b = forward(vmax) - forward(vmin)\n \n",
        "test_patch": "diff --git a/tests/_core/test_scales.py b/tests/_core/test_scales.py\n--- a/tests/_core/test_scales.py\n+++ b/tests/_core/test_scales.py\n@@ -90,6 +90,12 @@ def test_interval_with_range_norm_and_transform(self, x):\n         s = Continuous((2, 3), (10, 100), \"log\")._setup(x, IntervalProperty())\n         assert_array_equal(s(x), [1, 2, 3])\n \n+    def test_interval_with_bools(self):\n+\n+        x = pd.Series([True, False, False])\n+        s = Continuous()._setup(x, IntervalProperty())\n+        assert_array_equal(s(x), [1, 0, 0])\n+\n     def test_color_defaults(self, x):\n \n         cmap = color_palette(\"ch:\", as_cmap=True)\n",
        "problem_statement": "Color mapping fails with boolean data\n```python\r\nso.Plot([\"a\", \"b\"], [1, 2], color=[True, False]).add(so.Bar())\r\n```\r\n```python-traceback\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\n...\r\nFile ~/code/seaborn/seaborn/_core/plot.py:841, in Plot._plot(self, pyplot)\r\n    838 plotter._compute_stats(self, layers)\r\n    840 # Process scale spec for semantic variables and coordinates computed by stat\r\n--> 841 plotter._setup_scales(self, common, layers)\r\n    843 # TODO Remove these after updating other methods\r\n    844 # ---- Maybe have debug= param that attaches these when True?\r\n    845 plotter._data = common\r\n\r\nFile ~/code/seaborn/seaborn/_core/plot.py:1252, in Plotter._setup_scales(self, p, common, layers, variables)\r\n   1250     self._scales[var] = Scale._identity()\r\n   1251 else:\r\n-> 1252     self._scales[var] = scale._setup(var_df[var], prop)\r\n   1254 # Everything below here applies only to coordinate variables\r\n   1255 # We additionally skip it when we're working with a value\r\n   1256 # that is derived from a coordinate we've already processed.\r\n   1257 # e.g., the Stat consumed y and added ymin/ymax. In that case,\r\n   1258 # we've already setup the y scale and ymin/max are in scale space.\r\n   1259 if axis is None or (var != coord and coord in p._variables):\r\n\r\nFile ~/code/seaborn/seaborn/_core/scales.py:351, in ContinuousBase._setup(self, data, prop, axis)\r\n    349 vmin, vmax = axis.convert_units((vmin, vmax))\r\n    350 a = forward(vmin)\r\n--> 351 b = forward(vmax) - forward(vmin)\r\n    353 def normalize(x):\r\n    354     return (x - a) / b\r\n\r\nTypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead.\r\n```\n",
        "hints_text": "Would this simply mean refactoring the code to use `^` or `xor` functions instead?",
        "created_at": "2022-12-18T17:13:51Z",
        "version": "0.12",
        "FAIL_TO_PASS": "[\"tests/_core/test_scales.py::TestContinuous::test_interval_with_bools\"]",
        "PASS_TO_PASS": "[\"tests/_core/test_scales.py::TestContinuous::test_coordinate_defaults\", \"tests/_core/test_scales.py::TestContinuous::test_coordinate_transform\", \"tests/_core/test_scales.py::TestContinuous::test_coordinate_transform_with_parameter\", \"tests/_core/test_scales.py::TestContinuous::test_coordinate_transform_error\", \"tests/_core/test_scales.py::TestContinuous::test_interval_defaults\", \"tests/_core/test_scales.py::TestContinuous::test_interval_with_range\", \"tests/_core/test_scales.py::TestContinuous::test_interval_with_norm\", \"tests/_core/test_scales.py::TestContinuous::test_interval_with_range_norm_and_transform\", \"tests/_core/test_scales.py::TestContinuous::test_color_defaults\", \"tests/_core/test_scales.py::TestContinuous::test_color_named_values\", \"tests/_core/test_scales.py::TestContinuous::test_color_tuple_values\", \"tests/_core/test_scales.py::TestContinuous::test_color_callable_values\", \"tests/_core/test_scales.py::TestContinuous::test_color_with_norm\", \"tests/_core/test_scales.py::TestContinuous::test_color_with_transform\", \"tests/_core/test_scales.py::TestContinuous::test_tick_locator\", \"tests/_core/test_scales.py::TestContinuous::test_tick_locator_input_check\", \"tests/_core/test_scales.py::TestContinuous::test_tick_upto\", \"tests/_core/test_scales.py::TestContinuous::test_tick_every\", \"tests/_core/test_scales.py::TestContinuous::test_tick_every_between\", \"tests/_core/test_scales.py::TestContinuous::test_tick_at\", \"tests/_core/test_scales.py::TestContinuous::test_tick_count\", \"tests/_core/test_scales.py::TestContinuous::test_tick_count_between\", \"tests/_core/test_scales.py::TestContinuous::test_tick_minor\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_default\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_upto\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_count\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_format_disabled\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_every\", \"tests/_core/test_scales.py::TestContinuous::test_symlog_tick_default\", \"tests/_core/test_scales.py::TestContinuous::test_label_formatter\", \"tests/_core/test_scales.py::TestContinuous::test_label_like_pattern\", \"tests/_core/test_scales.py::TestContinuous::test_label_like_string\", \"tests/_core/test_scales.py::TestContinuous::test_label_like_function\", \"tests/_core/test_scales.py::TestContinuous::test_label_base\", \"tests/_core/test_scales.py::TestContinuous::test_label_unit\", \"tests/_core/test_scales.py::TestContinuous::test_label_unit_with_sep\", \"tests/_core/test_scales.py::TestContinuous::test_label_empty_unit\", \"tests/_core/test_scales.py::TestContinuous::test_label_base_from_transform\", \"tests/_core/test_scales.py::TestContinuous::test_label_type_checks\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_defaults\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_with_order\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_with_subset_order\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_axis\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_axis_with_order\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_axis_with_subset_order\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_axis_with_category_dtype\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_numeric_data\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_numeric_data_with_order\", \"tests/_core/test_scales.py::TestNominal::test_color_defaults\", \"tests/_core/test_scales.py::TestNominal::test_color_named_palette\", \"tests/_core/test_scales.py::TestNominal::test_color_list_palette\", \"tests/_core/test_scales.py::TestNominal::test_color_dict_palette\", \"tests/_core/test_scales.py::TestNominal::test_color_numeric_data\", \"tests/_core/test_scales.py::TestNominal::test_color_numeric_with_order_subset\", \"tests/_core/test_scales.py::TestNominal::test_color_alpha_in_palette\", \"tests/_core/test_scales.py::TestNominal::test_color_unknown_palette\", \"tests/_core/test_scales.py::TestNominal::test_object_defaults\", \"tests/_core/test_scales.py::TestNominal::test_object_list\", \"tests/_core/test_scales.py::TestNominal::test_object_dict\", \"tests/_core/test_scales.py::TestNominal::test_object_order\", \"tests/_core/test_scales.py::TestNominal::test_object_order_subset\", \"tests/_core/test_scales.py::TestNominal::test_objects_that_are_weird\", \"tests/_core/test_scales.py::TestNominal::test_alpha_default\", \"tests/_core/test_scales.py::TestNominal::test_fill\", \"tests/_core/test_scales.py::TestNominal::test_fill_dict\", \"tests/_core/test_scales.py::TestNominal::test_fill_nunique_warning\", \"tests/_core/test_scales.py::TestNominal::test_interval_defaults\", \"tests/_core/test_scales.py::TestNominal::test_interval_tuple\", \"tests/_core/test_scales.py::TestNominal::test_interval_tuple_numeric\", \"tests/_core/test_scales.py::TestNominal::test_interval_list\", \"tests/_core/test_scales.py::TestNominal::test_interval_dict\", \"tests/_core/test_scales.py::TestNominal::test_interval_with_transform\", \"tests/_core/test_scales.py::TestNominal::test_empty_data\", \"tests/_core/test_scales.py::TestTemporal::test_coordinate_defaults\", \"tests/_core/test_scales.py::TestTemporal::test_interval_defaults\", \"tests/_core/test_scales.py::TestTemporal::test_interval_with_range\", \"tests/_core/test_scales.py::TestTemporal::test_interval_with_norm\", \"tests/_core/test_scales.py::TestTemporal::test_color_defaults\", \"tests/_core/test_scales.py::TestTemporal::test_color_named_values\", \"tests/_core/test_scales.py::TestTemporal::test_coordinate_axis\", \"tests/_core/test_scales.py::TestTemporal::test_tick_locator\", \"tests/_core/test_scales.py::TestTemporal::test_tick_upto\", \"tests/_core/test_scales.py::TestTemporal::test_label_formatter\", \"tests/_core/test_scales.py::TestTemporal::test_label_concise\"]",
        "environment_setup_commit": "d25872b0fc99dbf7e666a91f59bd4ed125186aa1",
        "issue_title": "Color mapping fails with boolean data",
        "test_file": "/home/fdse/wy/RepoCodeEdit/data/raw_repo_lite/seaborn/tests/test_categorical.py",
        "searched_functions": [
            "def test_specific_palette(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test palette mapping the x position\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(None, \"dark\", 1)\n        assert p.colors == palettes.color_palette(\"dark\", 3)\n\n        # Test that non-None `color` and `hue` raises an error\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        p.establish_colors(None, \"muted\", 1)\n        assert p.colors == palettes.color_palette(\"muted\", 2)\n\n        # Test that specified palette overrides specified color\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(\"blue\", \"deep\", 1)\n        assert p.colors == palettes.color_palette(\"deep\", 3)",
            "def test_specific_color(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test the same color for each x position\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(\"blue\", None, 1)\n        blue_rgb = mpl.colors.colorConverter.to_rgb(\"blue\")\n        assert p.colors == [blue_rgb] * 3\n\n        # Test a color-based blend for the hue mapping\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        p.establish_colors(\"#ff0022\", None, 1)\n        rgba_array = np.array(palettes.light_palette(\"#ff0022\", 2))\n        npt.assert_array_almost_equal(p.colors,\n                                      rgba_array[:, :3])",
            "def test_hue_dodged(self, long_df, hue_var):\n\n        ax = self.func(data=long_df, x=\"y\", y=\"a\", hue=hue_var, dodge=True)\n        colors = color_palette(n_colors=long_df[hue_var].nunique())\n        collections = iter(ax.collections)\n\n        # Slightly awkward logic to handle challenges of how the artists work.\n        # e.g. there are empty scatter collections but the because facecolors\n        # for the empty collections will return the default scatter color\n        while colors:\n            points = next(collections)\n            if points.get_offsets().any():\n                face_color = tuple(points.get_facecolors()[0])\n                expected_color = to_rgba(colors.pop(0))\n                assert face_color == expected_color",
            "def test_color(self, long_df):\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"a\", y=\"y\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C0\")\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"a\", y=\"y\", ax=ax)\n        self.func(data=long_df, x=\"a\", y=\"y\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C1\")\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"a\", y=\"y\", color=\"C2\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C2\")\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"a\", y=\"y\", color=\"C3\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C3\")",
            "def test_different_defualt_colors(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"g\", y=\"y\", data=self.df))\n        p = cat._PointPlotter(**kws)\n        color = palettes.color_palette()[0]\n        npt.assert_array_equal(p.colors, [color, color, color])",
            "def test_default_palettes(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test palette mapping the x position\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(None, None, 1)\n        assert p.colors == palettes.color_palette(n_colors=3)\n\n        # Test palette mapping the hue position\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        p.establish_colors(None, None, 1)\n        assert p.colors == palettes.color_palette(n_colors=2)",
            "def test_dict_as_palette(self):\n\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        pal = {\"m\": (0, 0, 1), \"n\": (1, 0, 0)}\n        p.establish_colors(None, pal, 1)\n        assert p.colors == [(0, 0, 1), (1, 0, 0)]",
            "def test_palette_with_hue_deprecation(self, long_df):\n        palette = \"Blues\"\n        with pytest.warns(FutureWarning, match=\"Passing `palette` without\"):\n            ax = self.func(data=long_df, x=\"a\", y=long_df[\"y\"], palette=palette)\n        strips = ax.collections\n        colors = color_palette(palette, len(strips))\n        for strip, color in zip(strips, colors):\n            assert same_color(strip.get_facecolor()[0], color)",
            "def test_box_colors(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.boxenplot(\n            x=\"g\", y=\"y\", data=self.df, saturation=1, showfliers=False\n        )\n        ax.figure.canvas.draw()\n        for i, box in enumerate(ax.collections):\n            assert same_color(box.get_facecolor()[0], pal[i])\n\n        plt.close(\"all\")\n\n        ax = cat.boxenplot(\n            x=\"g\", y=\"y\", hue=\"h\", data=self.df, saturation=1, showfliers=False\n        )\n        ax.figure.canvas.draw()\n        for i, box in enumerate(ax.collections):\n            assert same_color(box.get_facecolor()[0], pal[i % 2])\n\n        plt.close(\"all\")",
            "def test_supplied_color_array(self, long_df):\n\n        cmap = get_colormap(\"Blues\")\n        norm = mpl.colors.Normalize()\n        colors = cmap(norm(long_df[\"y\"].to_numpy()))\n\n        keys = [\"c\", \"facecolor\", \"facecolors\"]\n\n        if Version(mpl.__version__) >= Version(\"3.1.0\"):\n            # https://github.com/matplotlib/matplotlib/pull/12851\n            keys.append(\"fc\")\n\n        for key in keys:\n\n            ax = plt.figure().subplots()\n            self.func(x=long_df[\"y\"], **{key: colors})\n            _draw_figure(ax.figure)\n            assert_array_equal(ax.collections[0].get_facecolors(), colors)\n\n        ax = plt.figure().subplots()\n        self.func(x=long_df[\"y\"], c=long_df[\"y\"], cmap=cmap)\n        _draw_figure(ax.figure)\n        assert_array_equal(ax.collections[0].get_facecolors(), colors)"
        ]
    },
    {
        "repo": "mwaskom/seaborn",
        "instance_id": "mwaskom__seaborn-3407",
        "base_commit": "515286e02be3e4c0ff2ef4addb34a53c4a676ee4",
        "patch": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1472,8 +1472,8 @@ def map_diag(self, func, **kwargs):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n",
        "test_patch": "diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py\n--- a/tests/test_axisgrid.py\n+++ b/tests/test_axisgrid.py\n@@ -1422,6 +1422,13 @@ def test_pairplot_markers(self):\n         with pytest.warns(UserWarning):\n             g = ag.pairplot(self.df, hue=\"a\", vars=vars, markers=markers[:-2])\n \n+    def test_pairplot_column_multiindex(self):\n+\n+        cols = pd.MultiIndex.from_arrays([[\"x\", \"y\"], [1, 2]])\n+        df = self.df[[\"x\", \"y\"]].set_axis(cols, axis=1)\n+        g = ag.pairplot(df)\n+        assert g.diag_vars == list(cols)\n+\n     def test_corner_despine(self):\n \n         g = ag.PairGrid(self.df, corner=True, despine=False)\n",
        "problem_statement": "pairplot raises KeyError with MultiIndex DataFrame\nWhen trying to pairplot a MultiIndex DataFrame, `pairplot` raises a `KeyError`:\r\n\r\nMRE:\r\n\r\n```python\r\nimport numpy as np\r\nimport pandas as pd\r\nimport seaborn as sns\r\n\r\n\r\ndata = {\r\n    (\"A\", \"1\"): np.random.rand(100),\r\n    (\"A\", \"2\"): np.random.rand(100),\r\n    (\"B\", \"1\"): np.random.rand(100),\r\n    (\"B\", \"2\"): np.random.rand(100),\r\n}\r\ndf = pd.DataFrame(data)\r\nsns.pairplot(df)\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n[c:\\Users\\KLuu\\anaconda3\\lib\\site-packages\\seaborn\\axisgrid.py](file:///C:/Users/KLuu/anaconda3/lib/site-packages/seaborn/axisgrid.py) in pairplot(data, hue, hue_order, palette, vars, x_vars, y_vars, kind, diag_kind, markers, height, aspect, corner, dropna, plot_kws, diag_kws, grid_kws, size)\r\n   2142     diag_kws.setdefault(\"legend\", False)\r\n   2143     if diag_kind == \"hist\":\r\n-> 2144         grid.map_diag(histplot, **diag_kws)\r\n   2145     elif diag_kind == \"kde\":\r\n   2146         diag_kws.setdefault(\"fill\", True)\r\n\r\n[c:\\Users\\KLuu\\anaconda3\\lib\\site-packages\\seaborn\\axisgrid.py](file:///C:/Users/KLuu/anaconda3/lib/site-packages/seaborn/axisgrid.py) in map_diag(self, func, **kwargs)\r\n   1488                 plt.sca(ax)\r\n   1489 \r\n-> 1490             vector = self.data[var]\r\n   1491             if self._hue_var is not None:\r\n   1492                 hue = self.data[self._hue_var]\r\n\r\n[c:\\Users\\KLuu\\anaconda3\\lib\\site-packages\\pandas\\core\\frame.py](file:///C:/Users/KLuu/anaconda3/lib/site-packages/pandas/core/frame.py) in __getitem__(self, key)\r\n   3765             if is_iterator(key):\r\n   3766                 key = list(key)\r\n-> 3767             indexer = self.columns._get_indexer_strict(key, \"columns\")[1]\r\n   3768 \r\n   3769         # take() does not accept boolean indexers\r\n\r\n[c:\\Users\\KLuu\\anaconda3\\lib\\site-packages\\pandas\\core\\indexes\\multi.py](file:///C:/Users/KLuu/anaconda3/lib/site-packages/pandas/core/indexes/multi.py) in _get_indexer_strict(self, key, axis_name)\r\n   2534             indexer = self._get_indexer_level_0(keyarr)\r\n   2535 \r\n-> 2536             self._raise_if_missing(key, indexer, axis_name)\r\n   2537             return self[indexer], indexer\r\n   2538 \r\n\r\n[c:\\Users\\KLuu\\anaconda3\\lib\\site-packages\\pandas\\core\\indexes\\multi.py](file:///C:/Users/KLuu/anaconda3/lib/site-packages/pandas/core/indexes/multi.py) in _raise_if_missing(self, key, indexer, axis_name)\r\n   2552                 cmask = check == -1\r\n   2553                 if cmask.any():\r\n-> 2554                     raise KeyError(f\"{keyarr[cmask]} not in index\")\r\n   2555                 # We get here when levels still contain values which are not\r\n   2556                 # actually in Index anymore\r\n\r\nKeyError: \"['1'] not in index\"\r\n```\r\n\r\nA workaround is to \"flatten\" the columns:\r\n\r\n```python\r\ndf.columns = [\"\".join(column) for column in df.columns]\r\n```\n",
        "hints_text": "",
        "created_at": "2023-06-27T23:17:29Z",
        "version": "0.13",
        "FAIL_TO_PASS": "[\"tests/test_axisgrid.py::TestPairGrid::test_pairplot_column_multiindex\"]",
        "PASS_TO_PASS": "[\"tests/test_axisgrid.py::TestFacetGrid::test_self_data\", \"tests/test_axisgrid.py::TestFacetGrid::test_self_figure\", \"tests/test_axisgrid.py::TestFacetGrid::test_self_axes\", \"tests/test_axisgrid.py::TestFacetGrid::test_axes_array_size\", \"tests/test_axisgrid.py::TestFacetGrid::test_single_axes\", \"tests/test_axisgrid.py::TestFacetGrid::test_col_wrap\", \"tests/test_axisgrid.py::TestFacetGrid::test_normal_axes\", \"tests/test_axisgrid.py::TestFacetGrid::test_wrapped_axes\", \"tests/test_axisgrid.py::TestFacetGrid::test_axes_dict\", \"tests/test_axisgrid.py::TestFacetGrid::test_figure_size\", \"tests/test_axisgrid.py::TestFacetGrid::test_figure_size_with_legend\", \"tests/test_axisgrid.py::TestFacetGrid::test_legend_data\", \"tests/test_axisgrid.py::TestFacetGrid::test_legend_data_missing_level\", \"tests/test_axisgrid.py::TestFacetGrid::test_get_boolean_legend_data\", \"tests/test_axisgrid.py::TestFacetGrid::test_legend_tuples\", \"tests/test_axisgrid.py::TestFacetGrid::test_legend_options\", \"tests/test_axisgrid.py::TestFacetGrid::test_legendout_with_colwrap\", \"tests/test_axisgrid.py::TestFacetGrid::test_legend_tight_layout\", \"tests/test_axisgrid.py::TestFacetGrid::test_subplot_kws\", \"tests/test_axisgrid.py::TestFacetGrid::test_gridspec_kws\", \"tests/test_axisgrid.py::TestFacetGrid::test_gridspec_kws_col_wrap\", \"tests/test_axisgrid.py::TestFacetGrid::test_data_generator\", \"tests/test_axisgrid.py::TestFacetGrid::test_map\", \"tests/test_axisgrid.py::TestFacetGrid::test_map_dataframe\", \"tests/test_axisgrid.py::TestFacetGrid::test_set\", \"tests/test_axisgrid.py::TestFacetGrid::test_set_titles\", \"tests/test_axisgrid.py::TestFacetGrid::test_set_titles_margin_titles\", \"tests/test_axisgrid.py::TestFacetGrid::test_set_ticklabels\", \"tests/test_axisgrid.py::TestFacetGrid::test_set_axis_labels\", \"tests/test_axisgrid.py::TestFacetGrid::test_axis_lims\", \"tests/test_axisgrid.py::TestFacetGrid::test_data_orders\", \"tests/test_axisgrid.py::TestFacetGrid::test_palette\", \"tests/test_axisgrid.py::TestFacetGrid::test_hue_kws\", \"tests/test_axisgrid.py::TestFacetGrid::test_dropna\", \"tests/test_axisgrid.py::TestFacetGrid::test_categorical_column_missing_categories\", \"tests/test_axisgrid.py::TestFacetGrid::test_categorical_warning\", \"tests/test_axisgrid.py::TestFacetGrid::test_refline\", \"tests/test_axisgrid.py::TestFacetGrid::test_apply\", \"tests/test_axisgrid.py::TestFacetGrid::test_pipe\", \"tests/test_axisgrid.py::TestFacetGrid::test_tick_params\", \"tests/test_axisgrid.py::TestPairGrid::test_self_data\", \"tests/test_axisgrid.py::TestPairGrid::test_ignore_datelike_data\", \"tests/test_axisgrid.py::TestPairGrid::test_self_figure\", \"tests/test_axisgrid.py::TestPairGrid::test_self_axes\", \"tests/test_axisgrid.py::TestPairGrid::test_default_axes\", \"tests/test_axisgrid.py::TestPairGrid::test_specific_square_axes[vars0]\", \"tests/test_axisgrid.py::TestPairGrid::test_specific_square_axes[vars1]\", \"tests/test_axisgrid.py::TestPairGrid::test_remove_hue_from_default\", \"tests/test_axisgrid.py::TestPairGrid::test_specific_nonsquare_axes[x_vars0-y_vars0]\", \"tests/test_axisgrid.py::TestPairGrid::test_specific_nonsquare_axes[x_vars1-z]\", \"tests/test_axisgrid.py::TestPairGrid::test_specific_nonsquare_axes[x_vars2-y_vars2]\", \"tests/test_axisgrid.py::TestPairGrid::test_corner\", \"tests/test_axisgrid.py::TestPairGrid::test_size\", \"tests/test_axisgrid.py::TestPairGrid::test_empty_grid\", \"tests/test_axisgrid.py::TestPairGrid::test_map\", \"tests/test_axisgrid.py::TestPairGrid::test_map_nonsquare\", \"tests/test_axisgrid.py::TestPairGrid::test_map_lower\", \"tests/test_axisgrid.py::TestPairGrid::test_map_upper\", \"tests/test_axisgrid.py::TestPairGrid::test_map_mixed_funcsig\", \"tests/test_axisgrid.py::TestPairGrid::test_map_diag\", \"tests/test_axisgrid.py::TestPairGrid::test_map_diag_rectangular\", \"tests/test_axisgrid.py::TestPairGrid::test_map_diag_color\", \"tests/test_axisgrid.py::TestPairGrid::test_map_diag_palette\", \"tests/test_axisgrid.py::TestPairGrid::test_map_diag_and_offdiag\", \"tests/test_axisgrid.py::TestPairGrid::test_diag_sharey\", \"tests/test_axisgrid.py::TestPairGrid::test_map_diag_matplotlib\", \"tests/test_axisgrid.py::TestPairGrid::test_palette\", \"tests/test_axisgrid.py::TestPairGrid::test_hue_kws\", \"tests/test_axisgrid.py::TestPairGrid::test_hue_order\", \"tests/test_axisgrid.py::TestPairGrid::test_hue_order_missing_level\", \"tests/test_axisgrid.py::TestPairGrid::test_hue_in_map\", \"tests/test_axisgrid.py::TestPairGrid::test_nondefault_index\", \"tests/test_axisgrid.py::TestPairGrid::test_dropna[scatterplot]\", \"tests/test_axisgrid.py::TestPairGrid::test_dropna[scatter]\", \"tests/test_axisgrid.py::TestPairGrid::test_histplot_legend\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot_reg\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot_reg_hue\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot_diag_kde\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot_kde\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot_hist\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot_markers\", \"tests/test_axisgrid.py::TestPairGrid::test_corner_despine\", \"tests/test_axisgrid.py::TestPairGrid::test_corner_set\", \"tests/test_axisgrid.py::TestPairGrid::test_legend\", \"tests/test_axisgrid.py::TestPairGrid::test_tick_params\", \"tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_lists\", \"tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_arrays\", \"tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_series\", \"tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe\", \"tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\", \"tests/test_axisgrid.py::TestJointGrid::test_margin_grid_axis_labels\", \"tests/test_axisgrid.py::TestJointGrid::test_dropna\", \"tests/test_axisgrid.py::TestJointGrid::test_axlims\", \"tests/test_axisgrid.py::TestJointGrid::test_marginal_ticks\", \"tests/test_axisgrid.py::TestJointGrid::test_bivariate_plot\", \"tests/test_axisgrid.py::TestJointGrid::test_univariate_plot\", \"tests/test_axisgrid.py::TestJointGrid::test_univariate_plot_distplot\", \"tests/test_axisgrid.py::TestJointGrid::test_univariate_plot_matplotlib\", \"tests/test_axisgrid.py::TestJointGrid::test_plot\", \"tests/test_axisgrid.py::TestJointGrid::test_space\", \"tests/test_axisgrid.py::TestJointGrid::test_hue[True]\", \"tests/test_axisgrid.py::TestJointGrid::test_hue[False]\", \"tests/test_axisgrid.py::TestJointGrid::test_refline\", \"tests/test_axisgrid.py::TestJointPlot::test_scatter\", \"tests/test_axisgrid.py::TestJointPlot::test_scatter_hue\", \"tests/test_axisgrid.py::TestJointPlot::test_reg\", \"tests/test_axisgrid.py::TestJointPlot::test_resid\", \"tests/test_axisgrid.py::TestJointPlot::test_hist\", \"tests/test_axisgrid.py::TestJointPlot::test_hex\", \"tests/test_axisgrid.py::TestJointPlot::test_kde\", \"tests/test_axisgrid.py::TestJointPlot::test_kde_hue\", \"tests/test_axisgrid.py::TestJointPlot::test_color\", \"tests/test_axisgrid.py::TestJointPlot::test_palette\", \"tests/test_axisgrid.py::TestJointPlot::test_hex_customise\", \"tests/test_axisgrid.py::TestJointPlot::test_bad_kind\", \"tests/test_axisgrid.py::TestJointPlot::test_unsupported_hue_kind\", \"tests/test_axisgrid.py::TestJointPlot::test_leaky_dict\", \"tests/test_axisgrid.py::TestJointPlot::test_distplot_kwarg_warning\", \"tests/test_axisgrid.py::TestJointPlot::test_ax_warning\"]",
        "environment_setup_commit": "23860365816440b050e9211e1c395a966de3c403",
        "issue_title": "pairplot raises KeyError with MultiIndex DataFrame",
        "test_file": "/home/fdse/wy/RepoCodeEdit/data/raw_repo_lite/seaborn/tests/test_axisgrid.py",
        "searched_functions": [
            "def test_nondefault_index(self):\n\n        df = self.df.copy().set_index(\"b\")\n\n        plot_vars = [\"x\", \"y\", \"z\"]\n        g1 = ag.PairGrid(df)\n        g1.map(plt.scatter)\n\n        for i, axes_i in enumerate(g1.axes):\n            for j, ax in enumerate(axes_i):\n                x_in = self.df[plot_vars[j]]\n                y_in = self.df[plot_vars[i]]\n                x_out, y_out = ax.collections[0].get_offsets().T\n                npt.assert_array_equal(x_in, x_out)\n                npt.assert_array_equal(y_in, y_out)\n\n        g2 = ag.PairGrid(df, hue=\"a\")\n        g2.map(plt.scatter)\n\n        for i, axes_i in enumerate(g2.axes):\n            for j, ax in enumerate(axes_i):\n                x_in = self.df[plot_vars[j]]\n                y_in = self.df[plot_vars[i]]\n                for k, k_level in enumerate(self.df.a.unique()):\n                    x_in_k = x_in[self.df.a == k_level]\n                    y_in_k = y_in[self.df.a == k_level]\n                    x_out, y_out = ax.collections[k].get_offsets().T\n                    npt.assert_array_equal(x_in_k, x_out)\n                    npt.assert_array_equal(y_in_k, y_out)",
            "def test_pairplot(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        g = ag.pairplot(self.df)\n\n        for ax in g.diag_axes:\n            assert len(ax.patches) > 1\n\n        for i, j in zip(*np.triu_indices_from(g.axes, 1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n        for i, j in zip(*np.tril_indices_from(g.axes, -1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n        for i, j in zip(*np.diag_indices_from(g.axes)):\n            ax = g.axes[i, j]\n            assert len(ax.collections) == 0\n\n        g = ag.pairplot(self.df, hue=\"a\")\n        n = len(self.df.a.unique())\n\n        for ax in g.diag_axes:\n            assert len(ax.collections) == n",
            "def test_pairplot_markers(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        markers = [\"o\", \"X\", \"s\"]\n        g = ag.pairplot(self.df, hue=\"a\", vars=vars, markers=markers)\n        m1 = get_legend_handles(g._legend)[0].get_paths()[0]\n        m2 = get_legend_handles(g._legend)[1].get_paths()[0]\n        assert m1 != m2\n\n        with pytest.warns(UserWarning):\n            g = ag.pairplot(self.df, hue=\"a\", vars=vars, markers=markers[:-2])",
            "def test_pairplot_diag_kde(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        g = ag.pairplot(self.df, diag_kind=\"kde\")\n\n        for ax in g.diag_axes:\n            assert len(ax.collections) == 1\n\n        for i, j in zip(*np.triu_indices_from(g.axes, 1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n        for i, j in zip(*np.tril_indices_from(g.axes, -1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n        for i, j in zip(*np.diag_indices_from(g.axes)):\n            ax = g.axes[i, j]\n            assert len(ax.collections) == 0",
            "def test_pairplot_reg(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        g = ag.pairplot(self.df, diag_kind=\"hist\", kind=\"reg\")\n\n        for ax in g.diag_axes:\n            assert len(ax.patches)\n\n        for i, j in zip(*np.triu_indices_from(g.axes, 1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n            assert len(ax.lines) == 1\n            assert len(ax.collections) == 2\n\n        for i, j in zip(*np.tril_indices_from(g.axes, -1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n            assert len(ax.lines) == 1\n            assert len(ax.collections) == 2\n\n        for i, j in zip(*np.diag_indices_from(g.axes)):\n            ax = g.axes[i, j]\n            assert len(ax.collections) == 0",
            "def test_pairplot_hist(self):\n\n        f, ax1 = plt.subplots()\n        histplot(data=self.df, x=\"x\", y=\"y\", ax=ax1)\n\n        g = ag.pairplot(self.df, kind=\"hist\")\n        ax2 = g.axes[1, 0]\n\n        assert_plots_equal(ax1, ax2, labels=False)",
            "def test_distplot_kwarg_warning(self, long_df):\n\n        with pytest.warns(UserWarning):\n            g = ag.jointplot(data=long_df, x=\"x\", y=\"y\", marginal_kws=dict(rug=True))\n        assert g.ax_marg_x.patches",
            "def test_pairplot_kde(self):\n\n        f, ax1 = plt.subplots()\n        kdeplot(data=self.df, x=\"x\", y=\"y\", ax=ax1)\n\n        g = ag.pairplot(self.df, kind=\"kde\")\n        ax2 = g.axes[1, 0]\n\n        assert_plots_equal(ax1, ax2, labels=False)",
            "def test_corner(self):\n\n        plot_vars = [\"x\", \"y\", \"z\"]\n        g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n        corner_size = sum(i + 1 for i in range(len(plot_vars)))\n        assert len(g.figure.axes) == corner_size\n\n        g.map_diag(plt.hist)\n        assert len(g.figure.axes) == (corner_size + len(plot_vars))\n\n        for ax in np.diag(g.axes):\n            assert not ax.yaxis.get_visible()\n\n        plot_vars = [\"x\", \"y\", \"z\"]\n        g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n        g.map(scatterplot)\n        assert len(g.figure.axes) == corner_size\n        assert g.axes[0, 0].get_ylabel() == \"x\"",
            "def test_map_upper(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        g = ag.PairGrid(self.df)\n        g.map_upper(plt.scatter)\n\n        for i, j in zip(*np.triu_indices_from(g.axes, 1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n        for i, j in zip(*np.tril_indices_from(g.axes)):\n            ax = g.axes[i, j]\n            assert len(ax.collections) == 0"
        ]
    }
]