[
    {
        "repo": "psf/requests",
        "instance_id": "psf__requests-3362",
        "base_commit": "36453b95b13079296776d11b09cab2567ea3e703",
        "patch": "diff --git a/requests/utils.py b/requests/utils.py\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -358,13 +358,20 @@ def get_encoding_from_headers(headers):\n \n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n+    encoding = r.encoding\n \n-    if r.encoding is None:\n-        for item in iterator:\n-            yield item\n-        return\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        # A LookupError is raised if the encoding was not found which could\n+        # indicate a misspelling or similar mistake.\n+        #\n+        # A TypeError can be raised if encoding is None\n+        raise UnicodeError(\"Unable to decode contents with encoding %s.\" % encoding)\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
        "test_patch": "diff --git a/tests/test_requests.py b/tests/test_requests.py\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -980,6 +980,13 @@ def test_response_decode_unicode(self):\n         chunks = r.iter_content(decode_unicode=True)\n         assert all(isinstance(chunk, str) for chunk in chunks)\n \n+        # check for encoding value of None\n+        r = requests.Response()\n+        r.raw = io.BytesIO(b'the content')\n+        r.encoding = None\n+        chunks = r.iter_content(decode_unicode=True)\n+        assert all(isinstance(chunk, str) for chunk in chunks)\n+\n     def test_response_chunk_size_int(self):\n         \"\"\"Ensure that chunk_size is passed as an integer, otherwise\n         raise a TypeError.\n",
        "problem_statement": "Uncertain about content/text vs iter_content(decode_unicode=True/False)\nWhen requesting an application/json document, I'm seeing `next(r.iter_content(16*1024, decode_unicode=True))` returning bytes, whereas `r.text` returns unicode. My understanding was that both should return a unicode object. In essence, I thought \"iter_content\" was equivalent to \"iter_text\" when decode_unicode was True. Have I misunderstood something? I can provide an example if needed.\n\nFor reference, I'm using python 3.5.1 and requests 2.10.0.\n\nThanks!\n\n",
        "hints_text": "what does (your response object).encoding return?\n\nThere's at least one key difference: `decode_unicode=True` doesn't fall back to `apparent_encoding`, which means it'll never autodetect the encoding. This means if `response.encoding` is None it is a no-op: in fact, it's a no-op that yields bytes.\n\nThat behaviour seems genuinely bad to me, so I think we should consider it a bug. I'd rather we had the same logic as in `text` for this.\n\n`r.encoding` returns `None`.\n\nOn a related note, `iter_text` might be clearer/more consistent than `iter_content(decode_unicode=True)` if there's room for change in the APIs future (and `iter_content_lines` and `iter_text_lines` I guess), assuming you don't see that as bloat.\n\n@mikepelley The API is presently frozen so I don't think we'll be adding those three methods. Besides, `iter_text` likely wouldn't provide much extra value outside of calling `iter_content(decode_unicode=True)`.\n",
        "created_at": "2016-06-24T13:31:31Z",
        "version": "2.10",
        "FAIL_TO_PASS": "[\"tests/test_requests.py::TestRequests::test_response_decode_unicode\"]",
        "PASS_TO_PASS": "[\"tests/test_requests.py::TestRequests::test_entry_points\", \"tests/test_requests.py::TestRequests::test_invalid_url[MissingSchema-hiwpefhipowhefopw]\", \"tests/test_requests.py::TestRequests::test_invalid_url[InvalidSchema-localhost:3128]\", \"tests/test_requests.py::TestRequests::test_invalid_url[InvalidSchema-localhost.localdomain:3128/]\", \"tests/test_requests.py::TestRequests::test_invalid_url[InvalidSchema-10.122.1.1:3128/]\", \"tests/test_requests.py::TestRequests::test_invalid_url[InvalidURL-http://]\", \"tests/test_requests.py::TestRequests::test_basic_building\", \"tests/test_requests.py::TestRequests::test_path_is_not_double_encoded\", \"tests/test_requests.py::TestRequests::test_params_are_added_before_fragment[http://example.com/path#fragment-http://example.com/path?a=b#fragment]\", \"tests/test_requests.py::TestRequests::test_params_are_added_before_fragment[http://example.com/path?key=value#fragment-http://example.com/path?key=value&a=b#fragment]\", \"tests/test_requests.py::TestRequests::test_params_original_order_is_preserved_by_default\", \"tests/test_requests.py::TestRequests::test_params_bytes_are_encoded\", \"tests/test_requests.py::TestRequests::test_binary_put\", \"tests/test_requests.py::TestRequests::test_errors[http://doesnotexist.google.com-ConnectionError]\", \"tests/test_requests.py::TestRequests::test_errors[http://localhost:1-ConnectionError]\", \"tests/test_requests.py::TestRequests::test_errors[http://fe80::5054:ff:fe5a:fc0-InvalidURL]\", \"tests/test_requests.py::TestRequests::test_proxy_error\", \"tests/test_requests.py::TestRequests::test_non_prepared_request_error\", \"tests/test_requests.py::TestRequests::test_prepare_request_with_bytestring_url\", \"tests/test_requests.py::TestRequests::test_links\", \"tests/test_requests.py::TestRequests::test_cookie_parameters\", \"tests/test_requests.py::TestRequests::test_cookie_as_dict_keeps_len\", \"tests/test_requests.py::TestRequests::test_cookie_as_dict_keeps_items\", \"tests/test_requests.py::TestRequests::test_cookie_as_dict_keys\", \"tests/test_requests.py::TestRequests::test_cookie_as_dict_values\", \"tests/test_requests.py::TestRequests::test_cookie_as_dict_items\", \"tests/test_requests.py::TestRequests::test_cookie_duplicate_names_different_domains\", \"tests/test_requests.py::TestRequests::test_cookie_duplicate_names_raises_cookie_conflict_error\", \"tests/test_requests.py::TestRequests::test_response_is_iterable\", \"tests/test_requests.py::TestRequests::test_response_chunk_size_int\", \"tests/test_requests.py::TestRequests::test_http_error\", \"tests/test_requests.py::TestRequests::test_transport_adapter_ordering\", \"tests/test_requests.py::TestRequests::test_long_authinfo_in_url\", \"tests/test_requests.py::TestRequests::test_nonhttp_schemes_dont_check_URLs\", \"tests/test_requests.py::TestRequests::test_basic_auth_str_is_always_native\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_init[cid0]\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_init[cid1]\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_init[cid2]\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_docstring_example\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_len\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_getitem\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_fixes_649\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_delitem\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_contains\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_get\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_update\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_update_retains_unchanged\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_iter\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_equality\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_setdefault\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_lower_items\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_preserve_key_case\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_preserve_last_key_case\", \"tests/test_requests.py::TestCaseInsensitiveDict::test_copy\", \"tests/test_requests.py::TestMorselToCookieExpires::test_expires_valid_str\", \"tests/test_requests.py::TestMorselToCookieExpires::test_expires_invalid_int[100-TypeError]\", \"tests/test_requests.py::TestMorselToCookieExpires::test_expires_invalid_int[woops-ValueError]\", \"tests/test_requests.py::TestMorselToCookieExpires::test_expires_none\", \"tests/test_requests.py::TestMorselToCookieMaxAge::test_max_age_valid_int\", \"tests/test_requests.py::TestMorselToCookieMaxAge::test_max_age_invalid_str\", \"tests/test_requests.py::TestTimeout::test_connect_timeout\", \"tests/test_requests.py::TestTimeout::test_total_timeout_connect\", \"tests/test_requests.py::test_json_encodes_as_bytes\", \"tests/test_requests.py::test_proxy_env_vars_override_default[http_proxy-http://example.com-socks5://proxy.com:9876]\", \"tests/test_requests.py::test_proxy_env_vars_override_default[https_proxy-https://example.com-socks5://proxy.com:9876]\", \"tests/test_requests.py::test_proxy_env_vars_override_default[all_proxy-http://example.com-socks5://proxy.com:9876]\", \"tests/test_requests.py::test_proxy_env_vars_override_default[all_proxy-https://example.com-socks5://proxy.com:9876]\", \"tests/test_requests.py::test_data_argument_accepts_tuples[data0]\", \"tests/test_requests.py::test_data_argument_accepts_tuples[data1]\", \"tests/test_requests.py::test_data_argument_accepts_tuples[data2]\", \"tests/test_requests.py::test_prepared_copy[None]\", \"tests/test_requests.py::test_prepared_copy[kwargs1]\", \"tests/test_requests.py::test_prepared_copy[kwargs2]\", \"tests/test_requests.py::test_prepared_copy[kwargs3]\", \"tests/test_requests.py::test_vendor_aliases\"]",
        "environment_setup_commit": "36453b95b13079296776d11b09cab2567ea3e703",
        "issue_title": "Uncertain about content/text vs iter_content(decode_unicode=True/False)",
        "test_file": "/home/fdse/wy/RepoCodeEdit/data/raw_repo_lite/requests/tests/test_requests.py",
        "searched_functions": [
            "def test_response_decode_unicode(self):\n        \"\"\"\n        When called with decode_unicode, Response.iter_content should always\n        return unicode.\n        \"\"\"\n        r = requests.Response()\n        r._content_consumed = True\n        r._content = b'the content'\n        r.encoding = 'ascii'\n\n        chunks = r.iter_content(decode_unicode=True)\n        assert all(isinstance(chunk, str) for chunk in chunks)\n\n        # also for streaming\n        r = requests.Response()\n        r.raw = io.BytesIO(b'the content')\n        r.encoding = 'ascii'\n        chunks = r.iter_content(decode_unicode=True)\n        assert all(isinstance(chunk, str) for chunk in chunks)",
            "def read_mock(amt, decode_content=None):\n            return read_(amt)",
            "def test_different_encodings_dont_break_post(self, httpbin):\n        r = requests.post(httpbin('post'),\n            data={'stuff': json.dumps({'a': 123})},\n            params={'blah': 'asdf1234'},\n            files={'file': ('test_requests.py', open(__file__, 'rb'))})\n        assert r.status_code == 200",
            "def test_custom_content_type(self, httpbin):\n        r = requests.post(\n            httpbin('post'),\n            data={'stuff': json.dumps({'a': 123})},\n            files={\n                'file1': ('test_requests.py', open(__file__, 'rb')),\n                'file2': ('test_requests', open(__file__, 'rb'),\n                    'text/py-content-type')})\n        assert r.status_code == 200\n        assert b\"text/py-content-type\" in r.request.body",
            "def test_override_content_length(self, httpbin):\n        headers = {\n            'Content-Length': 'not zero'\n        }\n        r = requests.Request('POST', httpbin('post'), headers=headers).prepare()\n        assert 'Content-Length' in r.headers\n        assert r.headers['Content-Length'] == 'not zero'",
            "def test_response_json_when_content_is_None(self, httpbin):\n        r = requests.get(httpbin('/status/204'))\n        # Make sure r.content is None\n        r.status_code = 0\n        r._content = False\n        r._content_consumed = False\n\n        assert r.content is None\n        with pytest.raises(ValueError):\n            r.json()",
            "def test_no_content_length(self, httpbin, method):\n        req = requests.Request(method, httpbin(method.lower())).prepare()\n        assert 'Content-Length' not in req.headers",
            "def test_response_is_iterable(self):\n        r = requests.Response()\n        io = StringIO.StringIO('abc')\n        read_ = io.read\n\n        def read_mock(amt, decode_content=None):\n            return read_(amt)\n        setattr(io, 'read', read_mock)\n        r.raw = io\n        assert next(iter(r))\n        io.close()",
            "def test_unicode_header_name(self, httpbin):\n        requests.put(\n            httpbin('put'),\n            headers={str('Content-Type'): 'application/octet-stream'},\n            data='\\xff')",
            "def test_unicode_method_name(self, httpbin):\n        files = {'file': open(__file__, 'rb')}\n        r = requests.request(\n            method=u('POST'), url=httpbin('post'), files=files)\n        assert r.status_code == 200"
        ],
        "imports_info": [
            "from __future__ import division",
            "import json",
            "import os",
            "import pickle",
            "import collections",
            "import contextlib",
            "import warnings",
            "import io",
            "import requests",
            "import pytest",
            "from requests.adapters import HTTPAdapter",
            "from requests.auth import HTTPDigestAuth, _basic_auth_str",
            "from requests.compat import Morsel, cookielib, getproxies, str, urlparse, builtin_str, OrderedDict",
            "from requests.cookies import cookiejar_from_dict, morsel_to_cookie",
            "from requests.exceptions import ConnectionError, ConnectTimeout, InvalidSchema, InvalidURL, MissingSchema, ReadTimeout, Timeout, RetryError, TooManyRedirects, ProxyError",
            "from requests.models import PreparedRequest",
            "from requests.structures import CaseInsensitiveDict",
            "from requests.sessions import SessionRedirectMixin",
            "from requests.models import urlencode",
            "from requests.hooks import default_hooks",
            "from compat import StringIO, u",
            "from utils import override_environ",
            "from ssl import SSLContext",
            "from requests.packages.urllib3.util import Retry",
            "from requests.packages import urllib3",
            "from requests.packages import chardet",
            "from requests.packages import webbrowser"
        ],
        "generated_tests": [
            "import requests\nimport pytest\n\nclass TestRequests:\n\n    def test_iter_content_decode_unicode(self):\n        url = 'https://jsonplaceholder.typicode.com/posts/1'  # A URL that returns JSON data\n        r = requests.get(url)\n\n        # Get the first chunk of content using iter_content with decode_unicode=True\n        first_chunk = next(r.iter_content(16*1024, decode_unicode=True))\n\n        # Assert that the type of the first chunk is str (which is unicode in Python 3)\n        assert isinstance(first_chunk, str), \"iter_content(decode_unicode=True) should return str, not bytes\"\n\n        # Get the content using the text property\n        text_content = r.text\n\n        # Assert that the type of the text content is also str\n        assert isinstance(text_content, str), \"text should return str\"\n\n        # Assert that the first chunk of content and the text content are the same\n        assert first_chunk == text_content[:len(first_chunk)], \"iter_content and text should return the same content\"",
            "import requests\nimport pytest\n\nclass TestRequests:\n\n    def test_iter_content_vs_text(self):\n        url = 'https://jsonplaceholder.typicode.com/posts/1'  # A URL that returns a JSON document\n        r = requests.get(url)\n\n        iter_content_result = next(r.iter_content(16*1024, decode_unicode=True))\n        text_result = r.text\n\n        assert isinstance(iter_content_result, str), 'iter_content does not return a unicode object'\n        assert isinstance(text_result, str), 'text does not return a unicode object'",
            "import requests\nimport pytest\n\nclass TestRequests:\n\n    def test_iter_content_vs_text(self):\n        url = 'https://jsonplaceholder.typicode.com/posts/1'  # A URL that returns a JSON document\n        r = requests.get(url)\n\n        # Get the response as unicode using r.text\n        text_response = r.text\n        assert isinstance(text_response, str), \"r.text did not return a unicode object\"\n\n        # Get the response as unicode using r.iter_content(decode_unicode=True)\n        iter_content_response = next(r.iter_content(16*1024, decode_unicode=True))\n        assert isinstance(iter_content_response, str), \"r.iter_content(decode_unicode=True) did not return a unicode object\"",
            "import requests\nimport pytest\n\nclass TestRequests:\n\n    def test_iter_content_vs_text(self):\n        url = \"https://jsonplaceholder.typicode.com/posts/1\"  # A URL that returns a JSON document\n        r = requests.get(url)\n\n        # Get the response as unicode using r.text\n        text_response = r.text\n        assert isinstance(text_response, str), \"r.text did not return a unicode object\"\n\n        # Get the response as unicode using r.iter_content(decode_unicode=True)\n        iter_content_response = next(r.iter_content(16*1024, decode_unicode=True))\n        assert isinstance(iter_content_response, str), \"r.iter_content(decode_unicode=True) did not return a unicode object\"",
            "import requests\nimport pytest\n\nclass TestRequests:\n\n    def test_iter_content_vs_text(self):\n        url = 'https://jsonplaceholder.typicode.com/posts/1'  # Known JSON endpoint\n        r = requests.get(url)\n\n        iter_content_result = next(r.iter_content(16*1024, decode_unicode=True))\n        text_result = r.text\n\n        assert isinstance(iter_content_result, str), 'iter_content did not return a string'\n        assert isinstance(text_result, str), 'text did not return a string'\n        assert type(iter_content_result) == type(text_result), 'iter_content and text returned different types'"
        ]
    }
]