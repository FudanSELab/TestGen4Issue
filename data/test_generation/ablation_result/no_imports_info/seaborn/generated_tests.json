[
    {
        "repo": "mwaskom/seaborn",
        "instance_id": "mwaskom__seaborn-3190",
        "base_commit": "4a9e54962a29c12a8b103d75f838e0e795a6974d",
        "patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -346,7 +346,7 @@ def _setup(\n                 vmin, vmax = data.min(), data.max()\n             else:\n                 vmin, vmax = new.norm\n-            vmin, vmax = axis.convert_units((vmin, vmax))\n+            vmin, vmax = map(float, axis.convert_units((vmin, vmax)))\n             a = forward(vmin)\n             b = forward(vmax) - forward(vmin)\n \n",
        "test_patch": "diff --git a/tests/_core/test_scales.py b/tests/_core/test_scales.py\n--- a/tests/_core/test_scales.py\n+++ b/tests/_core/test_scales.py\n@@ -90,6 +90,12 @@ def test_interval_with_range_norm_and_transform(self, x):\n         s = Continuous((2, 3), (10, 100), \"log\")._setup(x, IntervalProperty())\n         assert_array_equal(s(x), [1, 2, 3])\n \n+    def test_interval_with_bools(self):\n+\n+        x = pd.Series([True, False, False])\n+        s = Continuous()._setup(x, IntervalProperty())\n+        assert_array_equal(s(x), [1, 0, 0])\n+\n     def test_color_defaults(self, x):\n \n         cmap = color_palette(\"ch:\", as_cmap=True)\n",
        "problem_statement": "Color mapping fails with boolean data\n```python\r\nso.Plot([\"a\", \"b\"], [1, 2], color=[True, False]).add(so.Bar())\r\n```\r\n```python-traceback\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\n...\r\nFile ~/code/seaborn/seaborn/_core/plot.py:841, in Plot._plot(self, pyplot)\r\n    838 plotter._compute_stats(self, layers)\r\n    840 # Process scale spec for semantic variables and coordinates computed by stat\r\n--> 841 plotter._setup_scales(self, common, layers)\r\n    843 # TODO Remove these after updating other methods\r\n    844 # ---- Maybe have debug= param that attaches these when True?\r\n    845 plotter._data = common\r\n\r\nFile ~/code/seaborn/seaborn/_core/plot.py:1252, in Plotter._setup_scales(self, p, common, layers, variables)\r\n   1250     self._scales[var] = Scale._identity()\r\n   1251 else:\r\n-> 1252     self._scales[var] = scale._setup(var_df[var], prop)\r\n   1254 # Everything below here applies only to coordinate variables\r\n   1255 # We additionally skip it when we're working with a value\r\n   1256 # that is derived from a coordinate we've already processed.\r\n   1257 # e.g., the Stat consumed y and added ymin/ymax. In that case,\r\n   1258 # we've already setup the y scale and ymin/max are in scale space.\r\n   1259 if axis is None or (var != coord and coord in p._variables):\r\n\r\nFile ~/code/seaborn/seaborn/_core/scales.py:351, in ContinuousBase._setup(self, data, prop, axis)\r\n    349 vmin, vmax = axis.convert_units((vmin, vmax))\r\n    350 a = forward(vmin)\r\n--> 351 b = forward(vmax) - forward(vmin)\r\n    353 def normalize(x):\r\n    354     return (x - a) / b\r\n\r\nTypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead.\r\n```\n",
        "hints_text": "Would this simply mean refactoring the code to use `^` or `xor` functions instead?",
        "created_at": "2022-12-18T17:13:51Z",
        "version": "0.12",
        "FAIL_TO_PASS": "[\"tests/_core/test_scales.py::TestContinuous::test_interval_with_bools\"]",
        "PASS_TO_PASS": "[\"tests/_core/test_scales.py::TestContinuous::test_coordinate_defaults\", \"tests/_core/test_scales.py::TestContinuous::test_coordinate_transform\", \"tests/_core/test_scales.py::TestContinuous::test_coordinate_transform_with_parameter\", \"tests/_core/test_scales.py::TestContinuous::test_coordinate_transform_error\", \"tests/_core/test_scales.py::TestContinuous::test_interval_defaults\", \"tests/_core/test_scales.py::TestContinuous::test_interval_with_range\", \"tests/_core/test_scales.py::TestContinuous::test_interval_with_norm\", \"tests/_core/test_scales.py::TestContinuous::test_interval_with_range_norm_and_transform\", \"tests/_core/test_scales.py::TestContinuous::test_color_defaults\", \"tests/_core/test_scales.py::TestContinuous::test_color_named_values\", \"tests/_core/test_scales.py::TestContinuous::test_color_tuple_values\", \"tests/_core/test_scales.py::TestContinuous::test_color_callable_values\", \"tests/_core/test_scales.py::TestContinuous::test_color_with_norm\", \"tests/_core/test_scales.py::TestContinuous::test_color_with_transform\", \"tests/_core/test_scales.py::TestContinuous::test_tick_locator\", \"tests/_core/test_scales.py::TestContinuous::test_tick_locator_input_check\", \"tests/_core/test_scales.py::TestContinuous::test_tick_upto\", \"tests/_core/test_scales.py::TestContinuous::test_tick_every\", \"tests/_core/test_scales.py::TestContinuous::test_tick_every_between\", \"tests/_core/test_scales.py::TestContinuous::test_tick_at\", \"tests/_core/test_scales.py::TestContinuous::test_tick_count\", \"tests/_core/test_scales.py::TestContinuous::test_tick_count_between\", \"tests/_core/test_scales.py::TestContinuous::test_tick_minor\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_default\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_upto\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_count\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_format_disabled\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_every\", \"tests/_core/test_scales.py::TestContinuous::test_symlog_tick_default\", \"tests/_core/test_scales.py::TestContinuous::test_label_formatter\", \"tests/_core/test_scales.py::TestContinuous::test_label_like_pattern\", \"tests/_core/test_scales.py::TestContinuous::test_label_like_string\", \"tests/_core/test_scales.py::TestContinuous::test_label_like_function\", \"tests/_core/test_scales.py::TestContinuous::test_label_base\", \"tests/_core/test_scales.py::TestContinuous::test_label_unit\", \"tests/_core/test_scales.py::TestContinuous::test_label_unit_with_sep\", \"tests/_core/test_scales.py::TestContinuous::test_label_empty_unit\", \"tests/_core/test_scales.py::TestContinuous::test_label_base_from_transform\", \"tests/_core/test_scales.py::TestContinuous::test_label_type_checks\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_defaults\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_with_order\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_with_subset_order\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_axis\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_axis_with_order\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_axis_with_subset_order\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_axis_with_category_dtype\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_numeric_data\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_numeric_data_with_order\", \"tests/_core/test_scales.py::TestNominal::test_color_defaults\", \"tests/_core/test_scales.py::TestNominal::test_color_named_palette\", \"tests/_core/test_scales.py::TestNominal::test_color_list_palette\", \"tests/_core/test_scales.py::TestNominal::test_color_dict_palette\", \"tests/_core/test_scales.py::TestNominal::test_color_numeric_data\", \"tests/_core/test_scales.py::TestNominal::test_color_numeric_with_order_subset\", \"tests/_core/test_scales.py::TestNominal::test_color_alpha_in_palette\", \"tests/_core/test_scales.py::TestNominal::test_color_unknown_palette\", \"tests/_core/test_scales.py::TestNominal::test_object_defaults\", \"tests/_core/test_scales.py::TestNominal::test_object_list\", \"tests/_core/test_scales.py::TestNominal::test_object_dict\", \"tests/_core/test_scales.py::TestNominal::test_object_order\", \"tests/_core/test_scales.py::TestNominal::test_object_order_subset\", \"tests/_core/test_scales.py::TestNominal::test_objects_that_are_weird\", \"tests/_core/test_scales.py::TestNominal::test_alpha_default\", \"tests/_core/test_scales.py::TestNominal::test_fill\", \"tests/_core/test_scales.py::TestNominal::test_fill_dict\", \"tests/_core/test_scales.py::TestNominal::test_fill_nunique_warning\", \"tests/_core/test_scales.py::TestNominal::test_interval_defaults\", \"tests/_core/test_scales.py::TestNominal::test_interval_tuple\", \"tests/_core/test_scales.py::TestNominal::test_interval_tuple_numeric\", \"tests/_core/test_scales.py::TestNominal::test_interval_list\", \"tests/_core/test_scales.py::TestNominal::test_interval_dict\", \"tests/_core/test_scales.py::TestNominal::test_interval_with_transform\", \"tests/_core/test_scales.py::TestNominal::test_empty_data\", \"tests/_core/test_scales.py::TestTemporal::test_coordinate_defaults\", \"tests/_core/test_scales.py::TestTemporal::test_interval_defaults\", \"tests/_core/test_scales.py::TestTemporal::test_interval_with_range\", \"tests/_core/test_scales.py::TestTemporal::test_interval_with_norm\", \"tests/_core/test_scales.py::TestTemporal::test_color_defaults\", \"tests/_core/test_scales.py::TestTemporal::test_color_named_values\", \"tests/_core/test_scales.py::TestTemporal::test_coordinate_axis\", \"tests/_core/test_scales.py::TestTemporal::test_tick_locator\", \"tests/_core/test_scales.py::TestTemporal::test_tick_upto\", \"tests/_core/test_scales.py::TestTemporal::test_label_formatter\", \"tests/_core/test_scales.py::TestTemporal::test_label_concise\"]",
        "environment_setup_commit": "d25872b0fc99dbf7e666a91f59bd4ed125186aa1",
        "issue_title": "Color mapping fails with boolean data",
        "test_file": "/home/fdse/wy/RepoCodeEdit/data/raw_repo_lite/seaborn/tests/test_categorical.py",
        "searched_functions": [
            "def test_specific_palette(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test palette mapping the x position\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(None, \"dark\", 1)\n        assert p.colors == palettes.color_palette(\"dark\", 3)\n\n        # Test that non-None `color` and `hue` raises an error\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        p.establish_colors(None, \"muted\", 1)\n        assert p.colors == palettes.color_palette(\"muted\", 2)\n\n        # Test that specified palette overrides specified color\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(\"blue\", \"deep\", 1)\n        assert p.colors == palettes.color_palette(\"deep\", 3)",
            "def test_specific_color(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test the same color for each x position\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(\"blue\", None, 1)\n        blue_rgb = mpl.colors.colorConverter.to_rgb(\"blue\")\n        assert p.colors == [blue_rgb] * 3\n\n        # Test a color-based blend for the hue mapping\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        p.establish_colors(\"#ff0022\", None, 1)\n        rgba_array = np.array(palettes.light_palette(\"#ff0022\", 2))\n        npt.assert_array_almost_equal(p.colors,\n                                      rgba_array[:, :3])",
            "def test_hue_dodged(self, long_df, hue_var):\n\n        ax = self.func(data=long_df, x=\"y\", y=\"a\", hue=hue_var, dodge=True)\n        colors = color_palette(n_colors=long_df[hue_var].nunique())\n        collections = iter(ax.collections)\n\n        # Slightly awkward logic to handle challenges of how the artists work.\n        # e.g. there are empty scatter collections but the because facecolors\n        # for the empty collections will return the default scatter color\n        while colors:\n            points = next(collections)\n            if points.get_offsets().any():\n                face_color = tuple(points.get_facecolors()[0])\n                expected_color = to_rgba(colors.pop(0))\n                assert face_color == expected_color",
            "def test_color(self, long_df):\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"a\", y=\"y\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C0\")\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"a\", y=\"y\", ax=ax)\n        self.func(data=long_df, x=\"a\", y=\"y\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C1\")\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"a\", y=\"y\", color=\"C2\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C2\")\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"a\", y=\"y\", color=\"C3\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C3\")",
            "def test_different_defualt_colors(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"g\", y=\"y\", data=self.df))\n        p = cat._PointPlotter(**kws)\n        color = palettes.color_palette()[0]\n        npt.assert_array_equal(p.colors, [color, color, color])",
            "def test_default_palettes(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test palette mapping the x position\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(None, None, 1)\n        assert p.colors == palettes.color_palette(n_colors=3)\n\n        # Test palette mapping the hue position\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        p.establish_colors(None, None, 1)\n        assert p.colors == palettes.color_palette(n_colors=2)",
            "def test_dict_as_palette(self):\n\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        pal = {\"m\": (0, 0, 1), \"n\": (1, 0, 0)}\n        p.establish_colors(None, pal, 1)\n        assert p.colors == [(0, 0, 1), (1, 0, 0)]",
            "def test_palette_with_hue_deprecation(self, long_df):\n        palette = \"Blues\"\n        with pytest.warns(FutureWarning, match=\"Passing `palette` without\"):\n            ax = self.func(data=long_df, x=\"a\", y=long_df[\"y\"], palette=palette)\n        strips = ax.collections\n        colors = color_palette(palette, len(strips))\n        for strip, color in zip(strips, colors):\n            assert same_color(strip.get_facecolor()[0], color)",
            "def test_box_colors(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.boxenplot(\n            x=\"g\", y=\"y\", data=self.df, saturation=1, showfliers=False\n        )\n        ax.figure.canvas.draw()\n        for i, box in enumerate(ax.collections):\n            assert same_color(box.get_facecolor()[0], pal[i])\n\n        plt.close(\"all\")\n\n        ax = cat.boxenplot(\n            x=\"g\", y=\"y\", hue=\"h\", data=self.df, saturation=1, showfliers=False\n        )\n        ax.figure.canvas.draw()\n        for i, box in enumerate(ax.collections):\n            assert same_color(box.get_facecolor()[0], pal[i % 2])\n\n        plt.close(\"all\")",
            "def test_supplied_color_array(self, long_df):\n\n        cmap = get_colormap(\"Blues\")\n        norm = mpl.colors.Normalize()\n        colors = cmap(norm(long_df[\"y\"].to_numpy()))\n\n        keys = [\"c\", \"facecolor\", \"facecolors\"]\n\n        if Version(mpl.__version__) >= Version(\"3.1.0\"):\n            # https://github.com/matplotlib/matplotlib/pull/12851\n            keys.append(\"fc\")\n\n        for key in keys:\n\n            ax = plt.figure().subplots()\n            self.func(x=long_df[\"y\"], **{key: colors})\n            _draw_figure(ax.figure)\n            assert_array_equal(ax.collections[0].get_facecolors(), colors)\n\n        ax = plt.figure().subplots()\n        self.func(x=long_df[\"y\"], c=long_df[\"y\"], cmap=cmap)\n        _draw_figure(ax.figure)\n        assert_array_equal(ax.collections[0].get_facecolors(), colors)"
        ],
        "imports_info": [],
        "generated_tests": [
            "import pytest\nimport seaborn as sns\n\nclass TestBooleanColorMapping:\n    def test_boolean_color_mapping(self):\n        # Setup\n        x_values = [\"a\", \"b\"]\n        y_values = [1, 2]\n        color_values = [True, False]\n\n        # Exercise\n        try:\n            plot = sns.Plot(x_values, y_values, color=color_values)\n            plot.add(sns.Bar())\n        except TypeError as e:\n            pytest.fail(f\"Unexpected TypeError: {e}\")\n\n        # Verify\n        assert plot is not None, \"Plot should have been created successfully\"",
            "import seaborn as sns\nimport pandas as pd\nimport pytest\n\nclass TestBooleanColorMapping:\n    def setup(self):\n        # Create a simple dataframe with boolean color data\n        self.data = pd.DataFrame({\n            'x': ['a', 'b'],\n            'y': [1, 2],\n            'color': [True, False]\n        })\n\n    def test_boolean_color_mapping(self):\n        # Attempt to create a bar plot with boolean color data\n        try:\n            sns.barplot(x='x', y='y', hue='color', data=self.data)\n        except TypeError as e:\n            pytest.fail(f\"Test failed due to TypeError: {str(e)}\")",
            "import seaborn as sns\nimport pandas as pd\nimport pytest\n\nclass TestSeabornPlot:\n    def test_color_mapping_with_boolean_data(self):\n        # Create a dataframe with boolean color data\n        df = pd.DataFrame({\n            'x': ['a', 'b'],\n            'y': [1, 2],\n            'color': [True, False]\n        })\n\n        # Try to create a bar plot with boolean color data\n        try:\n            sns.barplot(x='x', y='y', data=df, hue='color')\n        except TypeError as e:\n            pytest.fail(f\"TypeError raised when it shouldn't be: {e}\")",
            "import pytest\nimport seaborn as sns\nimport pandas as pd\n\nclass TestSeabornPlot:\n\n    def test_boolean_color_values(self):\n        # Create a dataframe with boolean color values\n        df = pd.DataFrame({\n            'x': ['a', 'b'],\n            'y': [1, 2],\n            'color': [True, False]\n        })\n\n        # Try to create a bar plot with boolean color values\n        try:\n            sns.barplot(x='x', y='y', data=df, hue='color')\n        except TypeError as e:\n            pytest.fail(f\"Test failed due to TypeError: {e}\")",
            "import pytest\nimport seaborn as sns\nimport pandas as pd\n\nclass TestBooleanColorMapping:\n    def setup(self):\n        # Create a simple dataframe for testing\n        self.df = pd.DataFrame({\n            'x': ['a', 'b'],\n            'y': [1, 2],\n            'color': [True, False]\n        })\n\n    def test_boolean_color_mapping(self):\n        # Try to plot data using boolean values as color parameters\n        try:\n            sns.Plot(self.df['x'], self.df['y'], color=self.df['color']).add(sns.Bar())\n        except TypeError as e:\n            # If the error message is the same as the one in the issue description,\n            # it means the bug has not been fixed\n            assert str(e) != \"numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead.\""
        ]
    }
]