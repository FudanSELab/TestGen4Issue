[
    {
        "repo": "mwaskom/seaborn",
        "instance_id": "mwaskom__seaborn-2848",
        "base_commit": "94621cef29f80282436d73e8d2c0aa76dab81273",
        "patch": "diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -149,6 +149,13 @@ def _lookup_single(self, key):\n             # Use a value that's in the original data vector\n             value = self.lookup_table[key]\n         except KeyError:\n+\n+            if self.norm is None:\n+                # Currently we only get here in scatterplot with hue_order,\n+                # because scatterplot does not consider hue a grouping variable\n+                # So unused hue levels are in the data, but not the lookup table\n+                return (0, 0, 0, 0)\n+\n             # Use the colormap to interpolate between existing datapoints\n             # (e.g. in the context of making a continuous legend)\n             try:\n",
        "test_patch": "diff --git a/tests/test_relational.py b/tests/test_relational.py\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -9,6 +9,7 @@\n \n from seaborn.external.version import Version\n from seaborn.palettes import color_palette\n+from seaborn._oldcore import categorical_order\n \n from seaborn.relational import (\n     _RelationalPlotter,\n@@ -1623,6 +1624,16 @@ def test_supplied_color_array(self, long_df):\n         _draw_figure(ax.figure)\n         assert_array_equal(ax.collections[0].get_facecolors(), colors)\n \n+    def test_hue_order(self, long_df):\n+\n+        order = categorical_order(long_df[\"a\"])\n+        unused = order.pop()\n+\n+        ax = scatterplot(data=long_df, x=\"x\", y=\"y\", hue=\"a\", hue_order=order)\n+        points = ax.collections[0]\n+        assert (points.get_facecolors()[long_df[\"a\"] == unused] == 0).all()\n+        assert [t.get_text() for t in ax.legend_.texts] == order\n+\n     def test_linewidths(self, long_df):\n \n         f, ax = plt.subplots()\n",
        "problem_statement": "PairGrid errors with `hue` assigned in `map`\nIn seaborn version 0.9.0 I was able to use the following Code to plot scatterplots across a PairGrid with categorical hue. The reason I am not using the \"hue\" keyword in creating the PairGrid is, that I want one regression line (with regplot) and not one regression per hue-category.\r\n```python\r\nimport seaborn as sns\r\niris = sns.load_dataset(\"iris\")\r\ng = sns.PairGrid(iris, y_vars=[\"sepal_length\",\"sepal_width\"], x_vars=[\"petal_length\",\"petal_width\"])\r\ng.map(sns.scatterplot, hue=iris[\"species\"])\r\ng.map(sns.regplot, scatter=False)\r\n```\r\n\r\nHowever, since I updated to searbon 0.11.1 the following Error message occurs:\r\n```\r\n---------------------------------------------------------------------------\r\nKeyError                                  Traceback (most recent call last)\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in _lookup_single(self, key)\r\n    143             # Use a value that's in the original data vector\r\n--> 144             value = self.lookup_table[key]\r\n    145         except KeyError:\r\n\r\nKeyError: 'setosa'\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTypeError                                 Traceback (most recent call last)\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in _lookup_single(self, key)\r\n    148             try:\r\n--> 149                 normed = self.norm(key)\r\n    150             except TypeError as err:\r\n\r\nTypeError: 'NoneType' object is not callable\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-3-46dd21e9c95a> in <module>\r\n      2 iris = sns.load_dataset(\"iris\")\r\n      3 g = sns.PairGrid(iris, y_vars=[\"sepal_length\",\"sepal_width\"], x_vars=[\"petal_length\",\"species\"])\r\n----> 4 g.map(sns.scatterplot, hue=iris[\"species\"])\r\n      5 \r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/axisgrid.py in map(self, func, **kwargs)\r\n   1263         row_indices, col_indices = np.indices(self.axes.shape)\r\n   1264         indices = zip(row_indices.flat, col_indices.flat)\r\n-> 1265         self._map_bivariate(func, indices, **kwargs)\r\n   1266 \r\n   1267         return self\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/axisgrid.py in _map_bivariate(self, func, indices, **kwargs)\r\n   1463             if ax is None:  # i.e. we are in corner mode\r\n   1464                 continue\r\n-> 1465             self._plot_bivariate(x_var, y_var, ax, func, **kws)\r\n   1466         self._add_axis_labels()\r\n   1467 \r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/axisgrid.py in _plot_bivariate(self, x_var, y_var, ax, func, **kwargs)\r\n   1503         kwargs.setdefault(\"hue_order\", self._hue_order)\r\n   1504         kwargs.setdefault(\"palette\", self._orig_palette)\r\n-> 1505         func(x=x, y=y, **kwargs)\r\n   1506 \r\n   1507         self._update_legend_data(ax)\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_decorators.py in inner_f(*args, **kwargs)\r\n     44             )\r\n     45         kwargs.update({k: arg for k, arg in zip(sig.parameters, args)})\r\n---> 46         return f(**kwargs)\r\n     47     return inner_f\r\n     48 \r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/relational.py in scatterplot(x, y, hue, style, size, data, palette, hue_order, hue_norm, sizes, size_order, size_norm, markers, style_order, x_bins, y_bins, units, estimator, ci, n_boot, alpha, x_jitter, y_jitter, legend, ax, **kwargs)\r\n    818     p._attach(ax)\r\n    819 \r\n--> 820     p.plot(ax, kwargs)\r\n    821 \r\n    822     return ax\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/relational.py in plot(self, ax, kws)\r\n    626         # Apply the mapping from semantic variables to artist attributes\r\n    627         if \"hue\" in self.variables:\r\n--> 628             c = self._hue_map(data[\"hue\"])\r\n    629 \r\n    630         if \"size\" in self.variables:\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in __call__(self, key, *args, **kwargs)\r\n     61         \"\"\"Get the attribute(s) values for the data key.\"\"\"\r\n     62         if isinstance(key, (list, np.ndarray, pd.Series)):\r\n---> 63             return [self._lookup_single(k, *args, **kwargs) for k in key]\r\n     64         else:\r\n     65             return self._lookup_single(key, *args, **kwargs)\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in <listcomp>(.0)\r\n     61         \"\"\"Get the attribute(s) values for the data key.\"\"\"\r\n     62         if isinstance(key, (list, np.ndarray, pd.Series)):\r\n---> 63             return [self._lookup_single(k, *args, **kwargs) for k in key]\r\n     64         else:\r\n     65             return self._lookup_single(key, *args, **kwargs)\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in _lookup_single(self, key)\r\n    149                 normed = self.norm(key)\r\n    150             except TypeError as err:\r\n--> 151                 if np.isnan(key):\r\n    152                     value = (0, 0, 0, 0)\r\n    153                 else:\r\n\r\nTypeError: ufunc 'isnan' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''\r\n```\r\n\r\nMy further observations are:\r\n- the error does not occur when using the \"hue\" keyword when creating PairGrid\r\n- the error does not occur for numerical values for hue\r\n- changing the dtype to \"categorical\" does not help\r\n\r\nEdit:\r\nI tried all versions between 0.9.0 and the current release (0.11.1) and the error only occurs in the current release. If I use 0.11.0, the plot seems to work.\n",
        "hints_text": "The following workarounds seem to work:\r\n```\r\ng.map(sns.scatterplot, hue=iris[\"species\"], hue_order=iris[\"species\"].unique())\r\n```\r\nor\r\n```\r\ng.map(lambda x, y, **kwargs: sns.scatterplot(x=x, y=y, hue=iris[\"species\"]))\r\n```\n> ```\r\n> g.map(sns.scatterplot, hue=iris[\"species\"], hue_order=iris[\"species\"].unique())\r\n> ```\r\n\r\nThe workaround fixes the problem for me.\r\nThank you very much!\r\n\r\n@mwaskom Should I close the Issue or leave it open until the bug is fixed?\nThat's a good workaround, but it's still a bug. The problem is that `PairGrid` now lets `hue` at the grid-level delegate to the axes-level functions if they have `hue` in their signature. But it's not properly handling the case where `hue` is *not* set for the grid, but *is* specified for one mapped function. @jhncls's workaround suggests the fix.\r\n\r\nAn easier workaround would have been to set `PairGrid(..., hue=\"species\")` and then pass `.map(..., hue=None)` where you don't want to separate by species. But `regplot` is the one axis-level function that does not yet handle hue-mapping internally, so it doesn't work for this specific case. It would have if you wanted a single bivariate density over hue-mapped scatterplot points (i.e. [this example](http://seaborn.pydata.org/introduction.html#classes-and-functions-for-making-complex-graphics) or something similar.",
        "created_at": "2022-06-11T18:21:32Z",
        "version": "0.12",
        "FAIL_TO_PASS": "[\"tests/test_relational.py::TestScatterPlotter::test_hue_order\"]",
        "PASS_TO_PASS": "[\"tests/test_relational.py::TestRelationalPlotter::test_wide_df_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_df_with_nonnumeric_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_array_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_flat_array_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_flat_list_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_flat_series_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_list_of_series_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_list_of_arrays_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_list_of_list_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_dict_of_series_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_dict_of_arrays_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_wide_dict_of_lists_variables\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_complex\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_vectors[series]\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_vectors[numpy]\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_vectors[list]\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_wide\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_hues\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_sizes\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_styles\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_stringy_numerics\", \"tests/test_relational.py::TestRelationalPlotter::test_relplot_data\", \"tests/test_relational.py::TestRelationalPlotter::test_facet_variable_collision\", \"tests/test_relational.py::TestRelationalPlotter::test_ax_kwarg_removal\", \"tests/test_relational.py::TestLinePlotter::test_legend_data\", \"tests/test_relational.py::TestLinePlotter::test_plot\", \"tests/test_relational.py::TestLinePlotter::test_axis_labels\", \"tests/test_relational.py::TestScatterPlotter::test_color\", \"tests/test_relational.py::TestScatterPlotter::test_legend_data\", \"tests/test_relational.py::TestScatterPlotter::test_plot\", \"tests/test_relational.py::TestScatterPlotter::test_axis_labels\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_axes\", \"tests/test_relational.py::TestScatterPlotter::test_literal_attribute_vectors\", \"tests/test_relational.py::TestScatterPlotter::test_supplied_color_array\", \"tests/test_relational.py::TestScatterPlotter::test_linewidths\", \"tests/test_relational.py::TestScatterPlotter::test_size_norm_extrapolation\", \"tests/test_relational.py::TestScatterPlotter::test_datetime_scale\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics0]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics1]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics2]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics3]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics4]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics5]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics6]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics7]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics8]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics9]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics10]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics11]\", \"tests/test_relational.py::TestScatterPlotter::test_scatterplot_smoke\"]",
        "environment_setup_commit": "d25872b0fc99dbf7e666a91f59bd4ed125186aa1",
        "issue_title": "PairGrid errors with `hue` assigned in `map`",
        "test_file": "/home/fdse/wy/RepoCodeEdit/data/raw_repo_lite/seaborn/tests/test_axisgrid.py"
    },
    {
        "repo": "mwaskom/seaborn",
        "instance_id": "mwaskom__seaborn-3010",
        "base_commit": "0f5a013e2cf43562deec3b879458e59a73853813",
        "patch": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -38,7 +38,10 @@ def _fit_predict(self, data):\n \n     def __call__(self, data, groupby, orient, scales):\n \n-        return groupby.apply(data, self._fit_predict)\n+        return (\n+            groupby\n+            .apply(data.dropna(subset=[\"x\", \"y\"]), self._fit_predict)\n+        )\n \n \n @dataclass\n",
        "test_patch": "diff --git a/tests/_stats/test_regression.py b/tests/_stats/test_regression.py\n--- a/tests/_stats/test_regression.py\n+++ b/tests/_stats/test_regression.py\n@@ -4,6 +4,7 @@\n \n import pytest\n from numpy.testing import assert_array_equal, assert_array_almost_equal\n+from pandas.testing import assert_frame_equal\n \n from seaborn._core.groupby import GroupBy\n from seaborn._stats.regression import PolyFit\n@@ -50,3 +51,11 @@ def test_one_grouper(self, df):\n             grid = np.linspace(part[\"x\"].min(), part[\"x\"].max(), gridsize)\n             assert_array_equal(part[\"x\"], grid)\n             assert part[\"y\"].diff().diff().dropna().abs().gt(0).all()\n+\n+    def test_missing_data(self, df):\n+\n+        groupby = GroupBy([\"group\"])\n+        df.iloc[5:10] = np.nan\n+        res1 = PolyFit()(df[[\"x\", \"y\"]], groupby, \"x\", {})\n+        res2 = PolyFit()(df[[\"x\", \"y\"]].dropna(), groupby, \"x\", {})\n+        assert_frame_equal(res1, res2)\n\\ No newline at end of file\n",
        "problem_statement": "PolyFit is not robust to missing data\n```python\r\nso.Plot([1, 2, 3, None, 4], [1, 2, 3, 4, 5]).add(so.Line(), so.PolyFit())\r\n```\r\n\r\n<details><summary>Traceback</summary>\r\n\r\n```python-traceback\r\n---------------------------------------------------------------------------\r\nLinAlgError                               Traceback (most recent call last)\r\nFile ~/miniconda3/envs/seaborn-py39-latest/lib/python3.9/site-packages/IPython/core/formatters.py:343, in BaseFormatter.__call__(self, obj)\r\n    341     method = get_real_method(obj, self.print_method)\r\n    342     if method is not None:\r\n--> 343         return method()\r\n    344     return None\r\n    345 else:\r\n\r\nFile ~/code/seaborn/seaborn/_core/plot.py:265, in Plot._repr_png_(self)\r\n    263 def _repr_png_(self) -> tuple[bytes, dict[str, float]]:\r\n--> 265     return self.plot()._repr_png_()\r\n\r\nFile ~/code/seaborn/seaborn/_core/plot.py:804, in Plot.plot(self, pyplot)\r\n    800 \"\"\"\r\n    801 Compile the plot spec and return the Plotter object.\r\n    802 \"\"\"\r\n    803 with theme_context(self._theme_with_defaults()):\r\n--> 804     return self._plot(pyplot)\r\n\r\nFile ~/code/seaborn/seaborn/_core/plot.py:822, in Plot._plot(self, pyplot)\r\n    819 plotter._setup_scales(self, common, layers, coord_vars)\r\n    821 # Apply statistical transform(s)\r\n--> 822 plotter._compute_stats(self, layers)\r\n    824 # Process scale spec for semantic variables and coordinates computed by stat\r\n    825 plotter._setup_scales(self, common, layers)\r\n\r\nFile ~/code/seaborn/seaborn/_core/plot.py:1110, in Plotter._compute_stats(self, spec, layers)\r\n   1108     grouper = grouping_vars\r\n   1109 groupby = GroupBy(grouper)\r\n-> 1110 res = stat(df, groupby, orient, scales)\r\n   1112 if pair_vars:\r\n   1113     data.frames[coord_vars] = res\r\n\r\nFile ~/code/seaborn/seaborn/_stats/regression.py:41, in PolyFit.__call__(self, data, groupby, orient, scales)\r\n     39 def __call__(self, data, groupby, orient, scales):\r\n---> 41     return groupby.apply(data, self._fit_predict)\r\n\r\nFile ~/code/seaborn/seaborn/_core/groupby.py:109, in GroupBy.apply(self, data, func, *args, **kwargs)\r\n    106 grouper, groups = self._get_groups(data)\r\n    108 if not grouper:\r\n--> 109     return self._reorder_columns(func(data, *args, **kwargs), data)\r\n    111 parts = {}\r\n    112 for key, part_df in data.groupby(grouper, sort=False):\r\n\r\nFile ~/code/seaborn/seaborn/_stats/regression.py:30, in PolyFit._fit_predict(self, data)\r\n     28     xx = yy = []\r\n     29 else:\r\n---> 30     p = np.polyfit(x, y, self.order)\r\n     31     xx = np.linspace(x.min(), x.max(), self.gridsize)\r\n     32     yy = np.polyval(p, xx)\r\n\r\nFile <__array_function__ internals>:180, in polyfit(*args, **kwargs)\r\n\r\nFile ~/miniconda3/envs/seaborn-py39-latest/lib/python3.9/site-packages/numpy/lib/polynomial.py:668, in polyfit(x, y, deg, rcond, full, w, cov)\r\n    666 scale = NX.sqrt((lhs*lhs).sum(axis=0))\r\n    667 lhs /= scale\r\n--> 668 c, resids, rank, s = lstsq(lhs, rhs, rcond)\r\n    669 c = (c.T/scale).T  # broadcast scale coefficients\r\n    671 # warn on rank reduction, which indicates an ill conditioned matrix\r\n\r\nFile <__array_function__ internals>:180, in lstsq(*args, **kwargs)\r\n\r\nFile ~/miniconda3/envs/seaborn-py39-latest/lib/python3.9/site-packages/numpy/linalg/linalg.py:2300, in lstsq(a, b, rcond)\r\n   2297 if n_rhs == 0:\r\n   2298     # lapack can't handle n_rhs = 0 - so allocate the array one larger in that axis\r\n   2299     b = zeros(b.shape[:-2] + (m, n_rhs + 1), dtype=b.dtype)\r\n-> 2300 x, resids, rank, s = gufunc(a, b, rcond, signature=signature, extobj=extobj)\r\n   2301 if m == 0:\r\n   2302     x[...] = 0\r\n\r\nFile ~/miniconda3/envs/seaborn-py39-latest/lib/python3.9/site-packages/numpy/linalg/linalg.py:101, in _raise_linalgerror_lstsq(err, flag)\r\n    100 def _raise_linalgerror_lstsq(err, flag):\r\n--> 101     raise LinAlgError(\"SVD did not converge in Linear Least Squares\")\r\n\r\nLinAlgError: SVD did not converge in Linear Least Squares\r\n\r\n```\r\n\r\n</details>\n",
        "hints_text": "",
        "created_at": "2022-09-11T19:37:32Z",
        "version": "0.12",
        "FAIL_TO_PASS": "[\"tests/_stats/test_regression.py::TestPolyFit::test_missing_data\"]",
        "PASS_TO_PASS": "[\"tests/_stats/test_regression.py::TestPolyFit::test_no_grouper\", \"tests/_stats/test_regression.py::TestPolyFit::test_one_grouper\"]",
        "environment_setup_commit": "d25872b0fc99dbf7e666a91f59bd4ed125186aa1",
        "issue_title": "PolyFit is not robust to missing data",
        "test_file": "/home/fdse/wy/RepoCodeEdit/data/raw_repo_lite/seaborn/tests/_stats/test_regression.py"
    },
    {
        "repo": "mwaskom/seaborn",
        "instance_id": "mwaskom__seaborn-3190",
        "base_commit": "4a9e54962a29c12a8b103d75f838e0e795a6974d",
        "patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -346,7 +346,7 @@ def _setup(\n                 vmin, vmax = data.min(), data.max()\n             else:\n                 vmin, vmax = new.norm\n-            vmin, vmax = axis.convert_units((vmin, vmax))\n+            vmin, vmax = map(float, axis.convert_units((vmin, vmax)))\n             a = forward(vmin)\n             b = forward(vmax) - forward(vmin)\n \n",
        "test_patch": "diff --git a/tests/_core/test_scales.py b/tests/_core/test_scales.py\n--- a/tests/_core/test_scales.py\n+++ b/tests/_core/test_scales.py\n@@ -90,6 +90,12 @@ def test_interval_with_range_norm_and_transform(self, x):\n         s = Continuous((2, 3), (10, 100), \"log\")._setup(x, IntervalProperty())\n         assert_array_equal(s(x), [1, 2, 3])\n \n+    def test_interval_with_bools(self):\n+\n+        x = pd.Series([True, False, False])\n+        s = Continuous()._setup(x, IntervalProperty())\n+        assert_array_equal(s(x), [1, 0, 0])\n+\n     def test_color_defaults(self, x):\n \n         cmap = color_palette(\"ch:\", as_cmap=True)\n",
        "problem_statement": "Color mapping fails with boolean data\n```python\r\nso.Plot([\"a\", \"b\"], [1, 2], color=[True, False]).add(so.Bar())\r\n```\r\n```python-traceback\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\n...\r\nFile ~/code/seaborn/seaborn/_core/plot.py:841, in Plot._plot(self, pyplot)\r\n    838 plotter._compute_stats(self, layers)\r\n    840 # Process scale spec for semantic variables and coordinates computed by stat\r\n--> 841 plotter._setup_scales(self, common, layers)\r\n    843 # TODO Remove these after updating other methods\r\n    844 # ---- Maybe have debug= param that attaches these when True?\r\n    845 plotter._data = common\r\n\r\nFile ~/code/seaborn/seaborn/_core/plot.py:1252, in Plotter._setup_scales(self, p, common, layers, variables)\r\n   1250     self._scales[var] = Scale._identity()\r\n   1251 else:\r\n-> 1252     self._scales[var] = scale._setup(var_df[var], prop)\r\n   1254 # Everything below here applies only to coordinate variables\r\n   1255 # We additionally skip it when we're working with a value\r\n   1256 # that is derived from a coordinate we've already processed.\r\n   1257 # e.g., the Stat consumed y and added ymin/ymax. In that case,\r\n   1258 # we've already setup the y scale and ymin/max are in scale space.\r\n   1259 if axis is None or (var != coord and coord in p._variables):\r\n\r\nFile ~/code/seaborn/seaborn/_core/scales.py:351, in ContinuousBase._setup(self, data, prop, axis)\r\n    349 vmin, vmax = axis.convert_units((vmin, vmax))\r\n    350 a = forward(vmin)\r\n--> 351 b = forward(vmax) - forward(vmin)\r\n    353 def normalize(x):\r\n    354     return (x - a) / b\r\n\r\nTypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead.\r\n```\n",
        "hints_text": "Would this simply mean refactoring the code to use `^` or `xor` functions instead?",
        "created_at": "2022-12-18T17:13:51Z",
        "version": "0.12",
        "FAIL_TO_PASS": "[\"tests/_core/test_scales.py::TestContinuous::test_interval_with_bools\"]",
        "PASS_TO_PASS": "[\"tests/_core/test_scales.py::TestContinuous::test_coordinate_defaults\", \"tests/_core/test_scales.py::TestContinuous::test_coordinate_transform\", \"tests/_core/test_scales.py::TestContinuous::test_coordinate_transform_with_parameter\", \"tests/_core/test_scales.py::TestContinuous::test_coordinate_transform_error\", \"tests/_core/test_scales.py::TestContinuous::test_interval_defaults\", \"tests/_core/test_scales.py::TestContinuous::test_interval_with_range\", \"tests/_core/test_scales.py::TestContinuous::test_interval_with_norm\", \"tests/_core/test_scales.py::TestContinuous::test_interval_with_range_norm_and_transform\", \"tests/_core/test_scales.py::TestContinuous::test_color_defaults\", \"tests/_core/test_scales.py::TestContinuous::test_color_named_values\", \"tests/_core/test_scales.py::TestContinuous::test_color_tuple_values\", \"tests/_core/test_scales.py::TestContinuous::test_color_callable_values\", \"tests/_core/test_scales.py::TestContinuous::test_color_with_norm\", \"tests/_core/test_scales.py::TestContinuous::test_color_with_transform\", \"tests/_core/test_scales.py::TestContinuous::test_tick_locator\", \"tests/_core/test_scales.py::TestContinuous::test_tick_locator_input_check\", \"tests/_core/test_scales.py::TestContinuous::test_tick_upto\", \"tests/_core/test_scales.py::TestContinuous::test_tick_every\", \"tests/_core/test_scales.py::TestContinuous::test_tick_every_between\", \"tests/_core/test_scales.py::TestContinuous::test_tick_at\", \"tests/_core/test_scales.py::TestContinuous::test_tick_count\", \"tests/_core/test_scales.py::TestContinuous::test_tick_count_between\", \"tests/_core/test_scales.py::TestContinuous::test_tick_minor\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_default\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_upto\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_count\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_format_disabled\", \"tests/_core/test_scales.py::TestContinuous::test_log_tick_every\", \"tests/_core/test_scales.py::TestContinuous::test_symlog_tick_default\", \"tests/_core/test_scales.py::TestContinuous::test_label_formatter\", \"tests/_core/test_scales.py::TestContinuous::test_label_like_pattern\", \"tests/_core/test_scales.py::TestContinuous::test_label_like_string\", \"tests/_core/test_scales.py::TestContinuous::test_label_like_function\", \"tests/_core/test_scales.py::TestContinuous::test_label_base\", \"tests/_core/test_scales.py::TestContinuous::test_label_unit\", \"tests/_core/test_scales.py::TestContinuous::test_label_unit_with_sep\", \"tests/_core/test_scales.py::TestContinuous::test_label_empty_unit\", \"tests/_core/test_scales.py::TestContinuous::test_label_base_from_transform\", \"tests/_core/test_scales.py::TestContinuous::test_label_type_checks\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_defaults\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_with_order\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_with_subset_order\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_axis\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_axis_with_order\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_axis_with_subset_order\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_axis_with_category_dtype\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_numeric_data\", \"tests/_core/test_scales.py::TestNominal::test_coordinate_numeric_data_with_order\", \"tests/_core/test_scales.py::TestNominal::test_color_defaults\", \"tests/_core/test_scales.py::TestNominal::test_color_named_palette\", \"tests/_core/test_scales.py::TestNominal::test_color_list_palette\", \"tests/_core/test_scales.py::TestNominal::test_color_dict_palette\", \"tests/_core/test_scales.py::TestNominal::test_color_numeric_data\", \"tests/_core/test_scales.py::TestNominal::test_color_numeric_with_order_subset\", \"tests/_core/test_scales.py::TestNominal::test_color_alpha_in_palette\", \"tests/_core/test_scales.py::TestNominal::test_color_unknown_palette\", \"tests/_core/test_scales.py::TestNominal::test_object_defaults\", \"tests/_core/test_scales.py::TestNominal::test_object_list\", \"tests/_core/test_scales.py::TestNominal::test_object_dict\", \"tests/_core/test_scales.py::TestNominal::test_object_order\", \"tests/_core/test_scales.py::TestNominal::test_object_order_subset\", \"tests/_core/test_scales.py::TestNominal::test_objects_that_are_weird\", \"tests/_core/test_scales.py::TestNominal::test_alpha_default\", \"tests/_core/test_scales.py::TestNominal::test_fill\", \"tests/_core/test_scales.py::TestNominal::test_fill_dict\", \"tests/_core/test_scales.py::TestNominal::test_fill_nunique_warning\", \"tests/_core/test_scales.py::TestNominal::test_interval_defaults\", \"tests/_core/test_scales.py::TestNominal::test_interval_tuple\", \"tests/_core/test_scales.py::TestNominal::test_interval_tuple_numeric\", \"tests/_core/test_scales.py::TestNominal::test_interval_list\", \"tests/_core/test_scales.py::TestNominal::test_interval_dict\", \"tests/_core/test_scales.py::TestNominal::test_interval_with_transform\", \"tests/_core/test_scales.py::TestNominal::test_empty_data\", \"tests/_core/test_scales.py::TestTemporal::test_coordinate_defaults\", \"tests/_core/test_scales.py::TestTemporal::test_interval_defaults\", \"tests/_core/test_scales.py::TestTemporal::test_interval_with_range\", \"tests/_core/test_scales.py::TestTemporal::test_interval_with_norm\", \"tests/_core/test_scales.py::TestTemporal::test_color_defaults\", \"tests/_core/test_scales.py::TestTemporal::test_color_named_values\", \"tests/_core/test_scales.py::TestTemporal::test_coordinate_axis\", \"tests/_core/test_scales.py::TestTemporal::test_tick_locator\", \"tests/_core/test_scales.py::TestTemporal::test_tick_upto\", \"tests/_core/test_scales.py::TestTemporal::test_label_formatter\", \"tests/_core/test_scales.py::TestTemporal::test_label_concise\"]",
        "environment_setup_commit": "d25872b0fc99dbf7e666a91f59bd4ed125186aa1",
        "issue_title": "Color mapping fails with boolean data",
        "test_file": "/home/fdse/wy/RepoCodeEdit/data/raw_repo_lite/seaborn/tests/test_categorical.py"
    },
    {
        "repo": "mwaskom/seaborn",
        "instance_id": "mwaskom__seaborn-3407",
        "base_commit": "515286e02be3e4c0ff2ef4addb34a53c4a676ee4",
        "patch": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1472,8 +1472,8 @@ def map_diag(self, func, **kwargs):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n",
        "test_patch": "diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py\n--- a/tests/test_axisgrid.py\n+++ b/tests/test_axisgrid.py\n@@ -1422,6 +1422,13 @@ def test_pairplot_markers(self):\n         with pytest.warns(UserWarning):\n             g = ag.pairplot(self.df, hue=\"a\", vars=vars, markers=markers[:-2])\n \n+    def test_pairplot_column_multiindex(self):\n+\n+        cols = pd.MultiIndex.from_arrays([[\"x\", \"y\"], [1, 2]])\n+        df = self.df[[\"x\", \"y\"]].set_axis(cols, axis=1)\n+        g = ag.pairplot(df)\n+        assert g.diag_vars == list(cols)\n+\n     def test_corner_despine(self):\n \n         g = ag.PairGrid(self.df, corner=True, despine=False)\n",
        "problem_statement": "pairplot raises KeyError with MultiIndex DataFrame\nWhen trying to pairplot a MultiIndex DataFrame, `pairplot` raises a `KeyError`:\r\n\r\nMRE:\r\n\r\n```python\r\nimport numpy as np\r\nimport pandas as pd\r\nimport seaborn as sns\r\n\r\n\r\ndata = {\r\n    (\"A\", \"1\"): np.random.rand(100),\r\n    (\"A\", \"2\"): np.random.rand(100),\r\n    (\"B\", \"1\"): np.random.rand(100),\r\n    (\"B\", \"2\"): np.random.rand(100),\r\n}\r\ndf = pd.DataFrame(data)\r\nsns.pairplot(df)\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n[c:\\Users\\KLuu\\anaconda3\\lib\\site-packages\\seaborn\\axisgrid.py](file:///C:/Users/KLuu/anaconda3/lib/site-packages/seaborn/axisgrid.py) in pairplot(data, hue, hue_order, palette, vars, x_vars, y_vars, kind, diag_kind, markers, height, aspect, corner, dropna, plot_kws, diag_kws, grid_kws, size)\r\n   2142     diag_kws.setdefault(\"legend\", False)\r\n   2143     if diag_kind == \"hist\":\r\n-> 2144         grid.map_diag(histplot, **diag_kws)\r\n   2145     elif diag_kind == \"kde\":\r\n   2146         diag_kws.setdefault(\"fill\", True)\r\n\r\n[c:\\Users\\KLuu\\anaconda3\\lib\\site-packages\\seaborn\\axisgrid.py](file:///C:/Users/KLuu/anaconda3/lib/site-packages/seaborn/axisgrid.py) in map_diag(self, func, **kwargs)\r\n   1488                 plt.sca(ax)\r\n   1489 \r\n-> 1490             vector = self.data[var]\r\n   1491             if self._hue_var is not None:\r\n   1492                 hue = self.data[self._hue_var]\r\n\r\n[c:\\Users\\KLuu\\anaconda3\\lib\\site-packages\\pandas\\core\\frame.py](file:///C:/Users/KLuu/anaconda3/lib/site-packages/pandas/core/frame.py) in __getitem__(self, key)\r\n   3765             if is_iterator(key):\r\n   3766                 key = list(key)\r\n-> 3767             indexer = self.columns._get_indexer_strict(key, \"columns\")[1]\r\n   3768 \r\n   3769         # take() does not accept boolean indexers\r\n\r\n[c:\\Users\\KLuu\\anaconda3\\lib\\site-packages\\pandas\\core\\indexes\\multi.py](file:///C:/Users/KLuu/anaconda3/lib/site-packages/pandas/core/indexes/multi.py) in _get_indexer_strict(self, key, axis_name)\r\n   2534             indexer = self._get_indexer_level_0(keyarr)\r\n   2535 \r\n-> 2536             self._raise_if_missing(key, indexer, axis_name)\r\n   2537             return self[indexer], indexer\r\n   2538 \r\n\r\n[c:\\Users\\KLuu\\anaconda3\\lib\\site-packages\\pandas\\core\\indexes\\multi.py](file:///C:/Users/KLuu/anaconda3/lib/site-packages/pandas/core/indexes/multi.py) in _raise_if_missing(self, key, indexer, axis_name)\r\n   2552                 cmask = check == -1\r\n   2553                 if cmask.any():\r\n-> 2554                     raise KeyError(f\"{keyarr[cmask]} not in index\")\r\n   2555                 # We get here when levels still contain values which are not\r\n   2556                 # actually in Index anymore\r\n\r\nKeyError: \"['1'] not in index\"\r\n```\r\n\r\nA workaround is to \"flatten\" the columns:\r\n\r\n```python\r\ndf.columns = [\"\".join(column) for column in df.columns]\r\n```\n",
        "hints_text": "",
        "created_at": "2023-06-27T23:17:29Z",
        "version": "0.13",
        "FAIL_TO_PASS": "[\"tests/test_axisgrid.py::TestPairGrid::test_pairplot_column_multiindex\"]",
        "PASS_TO_PASS": "[\"tests/test_axisgrid.py::TestFacetGrid::test_self_data\", \"tests/test_axisgrid.py::TestFacetGrid::test_self_figure\", \"tests/test_axisgrid.py::TestFacetGrid::test_self_axes\", \"tests/test_axisgrid.py::TestFacetGrid::test_axes_array_size\", \"tests/test_axisgrid.py::TestFacetGrid::test_single_axes\", \"tests/test_axisgrid.py::TestFacetGrid::test_col_wrap\", \"tests/test_axisgrid.py::TestFacetGrid::test_normal_axes\", \"tests/test_axisgrid.py::TestFacetGrid::test_wrapped_axes\", \"tests/test_axisgrid.py::TestFacetGrid::test_axes_dict\", \"tests/test_axisgrid.py::TestFacetGrid::test_figure_size\", \"tests/test_axisgrid.py::TestFacetGrid::test_figure_size_with_legend\", \"tests/test_axisgrid.py::TestFacetGrid::test_legend_data\", \"tests/test_axisgrid.py::TestFacetGrid::test_legend_data_missing_level\", \"tests/test_axisgrid.py::TestFacetGrid::test_get_boolean_legend_data\", \"tests/test_axisgrid.py::TestFacetGrid::test_legend_tuples\", \"tests/test_axisgrid.py::TestFacetGrid::test_legend_options\", \"tests/test_axisgrid.py::TestFacetGrid::test_legendout_with_colwrap\", \"tests/test_axisgrid.py::TestFacetGrid::test_legend_tight_layout\", \"tests/test_axisgrid.py::TestFacetGrid::test_subplot_kws\", \"tests/test_axisgrid.py::TestFacetGrid::test_gridspec_kws\", \"tests/test_axisgrid.py::TestFacetGrid::test_gridspec_kws_col_wrap\", \"tests/test_axisgrid.py::TestFacetGrid::test_data_generator\", \"tests/test_axisgrid.py::TestFacetGrid::test_map\", \"tests/test_axisgrid.py::TestFacetGrid::test_map_dataframe\", \"tests/test_axisgrid.py::TestFacetGrid::test_set\", \"tests/test_axisgrid.py::TestFacetGrid::test_set_titles\", \"tests/test_axisgrid.py::TestFacetGrid::test_set_titles_margin_titles\", \"tests/test_axisgrid.py::TestFacetGrid::test_set_ticklabels\", \"tests/test_axisgrid.py::TestFacetGrid::test_set_axis_labels\", \"tests/test_axisgrid.py::TestFacetGrid::test_axis_lims\", \"tests/test_axisgrid.py::TestFacetGrid::test_data_orders\", \"tests/test_axisgrid.py::TestFacetGrid::test_palette\", \"tests/test_axisgrid.py::TestFacetGrid::test_hue_kws\", \"tests/test_axisgrid.py::TestFacetGrid::test_dropna\", \"tests/test_axisgrid.py::TestFacetGrid::test_categorical_column_missing_categories\", \"tests/test_axisgrid.py::TestFacetGrid::test_categorical_warning\", \"tests/test_axisgrid.py::TestFacetGrid::test_refline\", \"tests/test_axisgrid.py::TestFacetGrid::test_apply\", \"tests/test_axisgrid.py::TestFacetGrid::test_pipe\", \"tests/test_axisgrid.py::TestFacetGrid::test_tick_params\", \"tests/test_axisgrid.py::TestPairGrid::test_self_data\", \"tests/test_axisgrid.py::TestPairGrid::test_ignore_datelike_data\", \"tests/test_axisgrid.py::TestPairGrid::test_self_figure\", \"tests/test_axisgrid.py::TestPairGrid::test_self_axes\", \"tests/test_axisgrid.py::TestPairGrid::test_default_axes\", \"tests/test_axisgrid.py::TestPairGrid::test_specific_square_axes[vars0]\", \"tests/test_axisgrid.py::TestPairGrid::test_specific_square_axes[vars1]\", \"tests/test_axisgrid.py::TestPairGrid::test_remove_hue_from_default\", \"tests/test_axisgrid.py::TestPairGrid::test_specific_nonsquare_axes[x_vars0-y_vars0]\", \"tests/test_axisgrid.py::TestPairGrid::test_specific_nonsquare_axes[x_vars1-z]\", \"tests/test_axisgrid.py::TestPairGrid::test_specific_nonsquare_axes[x_vars2-y_vars2]\", \"tests/test_axisgrid.py::TestPairGrid::test_corner\", \"tests/test_axisgrid.py::TestPairGrid::test_size\", \"tests/test_axisgrid.py::TestPairGrid::test_empty_grid\", \"tests/test_axisgrid.py::TestPairGrid::test_map\", \"tests/test_axisgrid.py::TestPairGrid::test_map_nonsquare\", \"tests/test_axisgrid.py::TestPairGrid::test_map_lower\", \"tests/test_axisgrid.py::TestPairGrid::test_map_upper\", \"tests/test_axisgrid.py::TestPairGrid::test_map_mixed_funcsig\", \"tests/test_axisgrid.py::TestPairGrid::test_map_diag\", \"tests/test_axisgrid.py::TestPairGrid::test_map_diag_rectangular\", \"tests/test_axisgrid.py::TestPairGrid::test_map_diag_color\", \"tests/test_axisgrid.py::TestPairGrid::test_map_diag_palette\", \"tests/test_axisgrid.py::TestPairGrid::test_map_diag_and_offdiag\", \"tests/test_axisgrid.py::TestPairGrid::test_diag_sharey\", \"tests/test_axisgrid.py::TestPairGrid::test_map_diag_matplotlib\", \"tests/test_axisgrid.py::TestPairGrid::test_palette\", \"tests/test_axisgrid.py::TestPairGrid::test_hue_kws\", \"tests/test_axisgrid.py::TestPairGrid::test_hue_order\", \"tests/test_axisgrid.py::TestPairGrid::test_hue_order_missing_level\", \"tests/test_axisgrid.py::TestPairGrid::test_hue_in_map\", \"tests/test_axisgrid.py::TestPairGrid::test_nondefault_index\", \"tests/test_axisgrid.py::TestPairGrid::test_dropna[scatterplot]\", \"tests/test_axisgrid.py::TestPairGrid::test_dropna[scatter]\", \"tests/test_axisgrid.py::TestPairGrid::test_histplot_legend\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot_reg\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot_reg_hue\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot_diag_kde\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot_kde\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot_hist\", \"tests/test_axisgrid.py::TestPairGrid::test_pairplot_markers\", \"tests/test_axisgrid.py::TestPairGrid::test_corner_despine\", \"tests/test_axisgrid.py::TestPairGrid::test_corner_set\", \"tests/test_axisgrid.py::TestPairGrid::test_legend\", \"tests/test_axisgrid.py::TestPairGrid::test_tick_params\", \"tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_lists\", \"tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_arrays\", \"tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_series\", \"tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe\", \"tests/test_axisgrid.py::TestJointGrid::test_margin_grid_from_dataframe_bad_variable\", \"tests/test_axisgrid.py::TestJointGrid::test_margin_grid_axis_labels\", \"tests/test_axisgrid.py::TestJointGrid::test_dropna\", \"tests/test_axisgrid.py::TestJointGrid::test_axlims\", \"tests/test_axisgrid.py::TestJointGrid::test_marginal_ticks\", \"tests/test_axisgrid.py::TestJointGrid::test_bivariate_plot\", \"tests/test_axisgrid.py::TestJointGrid::test_univariate_plot\", \"tests/test_axisgrid.py::TestJointGrid::test_univariate_plot_distplot\", \"tests/test_axisgrid.py::TestJointGrid::test_univariate_plot_matplotlib\", \"tests/test_axisgrid.py::TestJointGrid::test_plot\", \"tests/test_axisgrid.py::TestJointGrid::test_space\", \"tests/test_axisgrid.py::TestJointGrid::test_hue[True]\", \"tests/test_axisgrid.py::TestJointGrid::test_hue[False]\", \"tests/test_axisgrid.py::TestJointGrid::test_refline\", \"tests/test_axisgrid.py::TestJointPlot::test_scatter\", \"tests/test_axisgrid.py::TestJointPlot::test_scatter_hue\", \"tests/test_axisgrid.py::TestJointPlot::test_reg\", \"tests/test_axisgrid.py::TestJointPlot::test_resid\", \"tests/test_axisgrid.py::TestJointPlot::test_hist\", \"tests/test_axisgrid.py::TestJointPlot::test_hex\", \"tests/test_axisgrid.py::TestJointPlot::test_kde\", \"tests/test_axisgrid.py::TestJointPlot::test_kde_hue\", \"tests/test_axisgrid.py::TestJointPlot::test_color\", \"tests/test_axisgrid.py::TestJointPlot::test_palette\", \"tests/test_axisgrid.py::TestJointPlot::test_hex_customise\", \"tests/test_axisgrid.py::TestJointPlot::test_bad_kind\", \"tests/test_axisgrid.py::TestJointPlot::test_unsupported_hue_kind\", \"tests/test_axisgrid.py::TestJointPlot::test_leaky_dict\", \"tests/test_axisgrid.py::TestJointPlot::test_distplot_kwarg_warning\", \"tests/test_axisgrid.py::TestJointPlot::test_ax_warning\"]",
        "environment_setup_commit": "23860365816440b050e9211e1c395a966de3c403",
        "issue_title": "pairplot raises KeyError with MultiIndex DataFrame",
        "test_file": "/home/fdse/wy/RepoCodeEdit/data/raw_repo_lite/seaborn/tests/test_axisgrid.py"
    }
]