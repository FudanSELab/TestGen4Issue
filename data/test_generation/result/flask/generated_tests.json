[
    {
        "repo": "pallets/flask",
        "instance_id": "pallets__flask-4045",
        "base_commit": "d8c37f43724cd9fb0870f77877b7c4c7e38a19e0",
        "patch": "diff --git a/src/flask/blueprints.py b/src/flask/blueprints.py\n--- a/src/flask/blueprints.py\n+++ b/src/flask/blueprints.py\n@@ -188,6 +188,10 @@ def __init__(\n             template_folder=template_folder,\n             root_path=root_path,\n         )\n+\n+        if \".\" in name:\n+            raise ValueError(\"'name' may not contain a dot '.' character.\")\n+\n         self.name = name\n         self.url_prefix = url_prefix\n         self.subdomain = subdomain\n@@ -360,12 +364,12 @@ def add_url_rule(\n         \"\"\"Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for\n         the :func:`url_for` function is prefixed with the name of the blueprint.\n         \"\"\"\n-        if endpoint:\n-            assert \".\" not in endpoint, \"Blueprint endpoints should not contain dots\"\n-        if view_func and hasattr(view_func, \"__name__\"):\n-            assert (\n-                \".\" not in view_func.__name__\n-            ), \"Blueprint view function name should not contain dots\"\n+        if endpoint and \".\" in endpoint:\n+            raise ValueError(\"'endpoint' may not contain a dot '.' character.\")\n+\n+        if view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\n+            raise ValueError(\"'view_func' name may not contain a dot '.' character.\")\n+\n         self.record(lambda s: s.add_url_rule(rule, endpoint, view_func, **options))\n \n     def app_template_filter(self, name: t.Optional[str] = None) -> t.Callable:\n",
        "test_patch": "diff --git a/tests/test_basic.py b/tests/test_basic.py\n--- a/tests/test_basic.py\n+++ b/tests/test_basic.py\n@@ -1631,7 +1631,7 @@ def something_else():\n \n \n def test_inject_blueprint_url_defaults(app):\n-    bp = flask.Blueprint(\"foo.bar.baz\", __name__, template_folder=\"template\")\n+    bp = flask.Blueprint(\"foo\", __name__, template_folder=\"template\")\n \n     @bp.url_defaults\n     def bp_defaults(endpoint, values):\n@@ -1644,12 +1644,12 @@ def view(page):\n     app.register_blueprint(bp)\n \n     values = dict()\n-    app.inject_url_defaults(\"foo.bar.baz.view\", values)\n+    app.inject_url_defaults(\"foo.view\", values)\n     expected = dict(page=\"login\")\n     assert values == expected\n \n     with app.test_request_context(\"/somepage\"):\n-        url = flask.url_for(\"foo.bar.baz.view\")\n+        url = flask.url_for(\"foo.view\")\n     expected = \"/login\"\n     assert url == expected\n \ndiff --git a/tests/test_blueprints.py b/tests/test_blueprints.py\n--- a/tests/test_blueprints.py\n+++ b/tests/test_blueprints.py\n@@ -1,5 +1,3 @@\n-import functools\n-\n import pytest\n from jinja2 import TemplateNotFound\n from werkzeug.http import parse_cache_control_header\n@@ -253,28 +251,9 @@ def test_templates_list(test_apps):\n     assert templates == [\"admin/index.html\", \"frontend/index.html\"]\n \n \n-def test_dotted_names(app, client):\n-    frontend = flask.Blueprint(\"myapp.frontend\", __name__)\n-    backend = flask.Blueprint(\"myapp.backend\", __name__)\n-\n-    @frontend.route(\"/fe\")\n-    def frontend_index():\n-        return flask.url_for(\"myapp.backend.backend_index\")\n-\n-    @frontend.route(\"/fe2\")\n-    def frontend_page2():\n-        return flask.url_for(\".frontend_index\")\n-\n-    @backend.route(\"/be\")\n-    def backend_index():\n-        return flask.url_for(\"myapp.frontend.frontend_index\")\n-\n-    app.register_blueprint(frontend)\n-    app.register_blueprint(backend)\n-\n-    assert client.get(\"/fe\").data.strip() == b\"/be\"\n-    assert client.get(\"/fe2\").data.strip() == b\"/fe\"\n-    assert client.get(\"/be\").data.strip() == b\"/fe\"\n+def test_dotted_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(\"app.ui\", __name__)\n \n \n def test_dotted_names_from_app(app, client):\n@@ -343,62 +322,19 @@ def index():\n def test_route_decorator_custom_endpoint_with_dots(app, client):\n     bp = flask.Blueprint(\"bp\", __name__)\n \n-    @bp.route(\"/foo\")\n-    def foo():\n-        return flask.request.endpoint\n-\n-    try:\n-\n-        @bp.route(\"/bar\", endpoint=\"bar.bar\")\n-        def foo_bar():\n-            return flask.request.endpoint\n-\n-    except AssertionError:\n-        pass\n-    else:\n-        raise AssertionError(\"expected AssertionError not raised\")\n-\n-    try:\n-\n-        @bp.route(\"/bar/123\", endpoint=\"bar.123\")\n-        def foo_bar_foo():\n-            return flask.request.endpoint\n-\n-    except AssertionError:\n-        pass\n-    else:\n-        raise AssertionError(\"expected AssertionError not raised\")\n-\n-    def foo_foo_foo():\n-        pass\n-\n-    pytest.raises(\n-        AssertionError,\n-        lambda: bp.add_url_rule(\"/bar/123\", endpoint=\"bar.123\", view_func=foo_foo_foo),\n-    )\n-\n-    pytest.raises(\n-        AssertionError, bp.route(\"/bar/123\", endpoint=\"bar.123\"), lambda: None\n-    )\n-\n-    foo_foo_foo.__name__ = \"bar.123\"\n+    with pytest.raises(ValueError):\n+        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n \n-    pytest.raises(\n-        AssertionError, lambda: bp.add_url_rule(\"/bar/123\", view_func=foo_foo_foo)\n-    )\n+    with pytest.raises(ValueError):\n+        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n \n-    bp.add_url_rule(\n-        \"/bar/456\", endpoint=\"foofoofoo\", view_func=functools.partial(foo_foo_foo)\n-    )\n+    def view():\n+        return \"\"\n \n-    app.register_blueprint(bp, url_prefix=\"/py\")\n+    view.__name__ = \"a.b\"\n \n-    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n-    # The rule's didn't actually made it through\n-    rv = client.get(\"/py/bar\")\n-    assert rv.status_code == 404\n-    rv = client.get(\"/py/bar/123\")\n-    assert rv.status_code == 404\n+    with pytest.raises(ValueError):\n+        bp.add_url_rule(\"/\", view_func=view)\n \n \n def test_endpoint_decorator(app, client):\n",
        "problem_statement": "Raise error when blueprint name contains a dot\nThis is required since every dot is now significant since blueprints can be nested. An error was already added for endpoint names in 1.0, but should have been added for this as well.\n",
        "hints_text": "",
        "created_at": "2021-05-13T21:32:41Z",
        "version": "2.0",
        "FAIL_TO_PASS": "[\"tests/test_blueprints.py::test_dotted_name_not_allowed\", \"tests/test_blueprints.py::test_route_decorator_custom_endpoint_with_dots\"]",
        "PASS_TO_PASS": "[\"tests/test_basic.py::test_method_route_no_methods\", \"tests/test_basic.py::test_disallow_string_for_allowed_methods\", \"tests/test_basic.py::test_error_handler_unknown_code\", \"tests/test_basic.py::test_request_locals\", \"tests/test_basic.py::test_exception_propagation\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-True-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-True-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-False-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-False-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-True-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-True-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-False-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-False-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-True-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-True-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-False-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-False-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-True-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-True-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-False-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-False-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-True-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-True-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-False-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-False-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-True-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-True-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-False-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-False-False]\", \"tests/test_basic.py::test_get_method_on_g\", \"tests/test_basic.py::test_g_iteration_protocol\", \"tests/test_basic.py::test_run_defaults\", \"tests/test_basic.py::test_run_server_port\", \"tests/test_basic.py::test_run_from_config[None-None-pocoo.org:8080-pocoo.org-8080]\", \"tests/test_basic.py::test_run_from_config[localhost-None-pocoo.org:8080-localhost-8080]\", \"tests/test_basic.py::test_run_from_config[None-80-pocoo.org:8080-pocoo.org-80]\", \"tests/test_basic.py::test_run_from_config[localhost-80-pocoo.org:8080-localhost-80]\", \"tests/test_basic.py::test_run_from_config[localhost-0-localhost:8080-localhost-0]\", \"tests/test_basic.py::test_run_from_config[None-None-localhost:8080-localhost-8080]\", \"tests/test_basic.py::test_run_from_config[None-None-localhost:0-localhost-0]\", \"tests/test_basic.py::test_app_freed_on_zero_refcount\", \"tests/test_blueprints.py::test_template_filter\", \"tests/test_blueprints.py::test_add_template_filter\", \"tests/test_blueprints.py::test_template_filter_with_name\", \"tests/test_blueprints.py::test_add_template_filter_with_name\", \"tests/test_blueprints.py::test_template_test\", \"tests/test_blueprints.py::test_add_template_test\", \"tests/test_blueprints.py::test_template_test_with_name\", \"tests/test_blueprints.py::test_add_template_test_with_name\", \"tests/test_blueprints.py::test_template_global\"]",
        "environment_setup_commit": "4346498c85848c53843b810537b83a8f6124c9d3",
        "issue_title": "Raise error when blueprint name contains a dot",
        "test_file": "/home/fdse/wy/RepoCodeEdit/data/raw_repo_lite/flask/tests/test_blueprints.py",
        "searched_functions": [
            "def test_blueprint_specific_user_error_handling(app, client):\n    class MyDecoratorException(Exception):\n        pass\n\n    class MyFunctionException(Exception):\n        pass\n\n    blue = flask.Blueprint(\"blue\", __name__)\n\n    @blue.errorhandler(MyDecoratorException)\n    def my_decorator_exception_handler(e):\n        assert isinstance(e, MyDecoratorException)\n        return \"boom\"\n\n    def my_function_exception_handler(e):\n        assert isinstance(e, MyFunctionException)\n        return \"bam\"\n\n    blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n    @blue.route(\"/decorator\")\n    def blue_deco_test():\n        raise MyDecoratorException()\n\n    @blue.route(\"/function\")\n    def blue_func_test():\n        raise MyFunctionException()\n\n    app.register_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"",
            "def test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"",
            "def test_blueprint_specific_error_handling(app, client):\n    frontend = flask.Blueprint(\"frontend\", __name__)\n    backend = flask.Blueprint(\"backend\", __name__)\n    sideend = flask.Blueprint(\"sideend\", __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return \"frontend says no\", 403\n\n    @frontend.route(\"/frontend-no\")\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return \"backend says no\", 403\n\n    @backend.route(\"/backend-no\")\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route(\"/what-is-a-sideend\")\n    def sideend_no():\n        flask.abort(403)\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return \"application itself says no\", 403\n\n    assert client.get(\"/frontend-no\").data == b\"frontend says no\"\n    assert client.get(\"/backend-no\").data == b\"backend says no\"\n    assert client.get(\"/what-is-a-sideend\").data == b\"application itself says no\"",
            "def test_dotted_names(app, client):\n    frontend = flask.Blueprint(\"myapp.frontend\", __name__)\n    backend = flask.Blueprint(\"myapp.backend\", __name__)\n\n    @frontend.route(\"/fe\")\n    def frontend_index():\n        return flask.url_for(\"myapp.backend.backend_index\")\n\n    @frontend.route(\"/fe2\")\n    def frontend_page2():\n        return flask.url_for(\".frontend_index\")\n\n    @backend.route(\"/be\")\n    def backend_index():\n        return flask.url_for(\"myapp.frontend.frontend_index\")\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n\n    assert client.get(\"/fe\").data.strip() == b\"/be\"\n    assert client.get(\"/fe2\").data.strip() == b\"/fe\"\n    assert client.get(\"/be\").data.strip() == b\"/fe\"",
            "def test_dotted_names_from_app(app, client):\n    test = flask.Blueprint(\"test\", __name__)\n\n    @app.route(\"/\")\n    def app_index():\n        return flask.url_for(\"test.index\")\n\n    @test.route(\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\"",
            "def test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"",
            "def test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    try:\n\n        @bp.route(\"/bar\", endpoint=\"bar.bar\")\n        def foo_bar():\n            return flask.request.endpoint\n\n    except AssertionError:\n        pass\n    else:\n        raise AssertionError(\"expected AssertionError not raised\")\n\n    try:\n\n        @bp.route(\"/bar/123\", endpoint=\"bar.123\")\n        def foo_bar_foo():\n            return flask.request.endpoint\n\n    except AssertionError:\n        pass\n    else:\n        raise AssertionError(\"expected AssertionError not raised\")\n\n    def foo_foo_foo():\n        pass\n\n    pytest.raises(\n        AssertionError,\n        lambda: bp.add_url_rule(\"/bar/123\", endpoint=\"bar.123\", view_func=foo_foo_foo),\n    )\n\n    pytest.raises(\n        AssertionError, bp.route(\"/bar/123\", endpoint=\"bar.123\"), lambda: None\n    )\n\n    foo_foo_foo.__name__ = \"bar.123\"\n\n    pytest.raises(\n        AssertionError, lambda: bp.add_url_rule(\"/bar/123\", view_func=foo_foo_foo)\n    )\n\n    bp.add_url_rule(\n        \"/bar/456\", endpoint=\"foofoofoo\", view_func=functools.partial(foo_foo_foo)\n    )\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    # The rule's didn't actually made it through\n    rv = client.get(\"/py/bar\")\n    assert rv.status_code == 404\n    rv = client.get(\"/py/bar/123\")\n    assert rv.status_code == 404",
            "def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204",
            "def blue_deco_test():\n        raise MyDecoratorException()",
            "def test_default_static_max_age(app):\n    class MyBlueprint(flask.Blueprint):\n        def get_send_file_max_age(self, filename):\n            return 100\n\n    blueprint = MyBlueprint(\"blueprint\", __name__, static_folder=\"static\")\n    app.register_blueprint(blueprint)\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        with app.test_request_context():\n            unexpected_max_age = 3600\n            if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == unexpected_max_age:\n                unexpected_max_age = 7200\n            app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = unexpected_max_age\n            rv = blueprint.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default"
        ],
        "imports_info": [
            "import functools",
            "import pytest",
            "from jinja2 import TemplateNotFound",
            "from werkzeug.http import parse_cache_control_header",
            "import flask",
            "from blueprintapp import app",
            "from blueprintapp import app",
            "from werkzeug.routing import Rule"
        ],
        "generated_tests": [
            "import pytest\nimport flask\nfrom blueprintapp import app\n\nclass TestBlueprintName:\n    def test_blueprint_name_with_dot(self):\n        with pytest.raises(ValueError):\n            bad_blueprint = flask.Blueprint(\"bad.name\", __name__)\n            app.register_blueprint(bad_blueprint)",
            "import pytest\nimport flask\nfrom blueprintapp import app\n\nclass TestBlueprintName:\n    def test_blueprint_name_with_dot(self):\n        with pytest.raises(ValueError):\n            blue = flask.Blueprint(\"blue.dot\", __name__)\n            app.register_blueprint(blue)",
            "import pytest\nimport flask\nfrom blueprintapp import app\n\nclass TestBlueprintName:\n    def test_blueprint_name_with_dot(self):\n        with pytest.raises(ValueError):\n            blue = flask.Blueprint(\"blue.dot\", __name__)\n            app.register_blueprint(blue)",
            "import pytest\nimport flask\nfrom blueprintapp import app\n\nclass TestBlueprintName:\n    def test_blueprint_name_with_dot(self):\n        with pytest.raises(ValueError):\n            blue = flask.Blueprint(\"blue.dot\", __name__)\n            app.register_blueprint(blue)",
            "import pytest\nimport flask\nfrom blueprintapp import app\n\nclass TestBlueprintName:\n    def test_blueprint_name_with_dot(self):\n        with pytest.raises(ValueError):\n            bad_blueprint = flask.Blueprint(\"bad.name\", __name__)\n            app.register_blueprint(bad_blueprint)"
        ]
    },
    {
        "repo": "pallets/flask",
        "instance_id": "pallets__flask-5063",
        "base_commit": "182ce3dd15dfa3537391c3efaf9c3ff407d134d4",
        "patch": "diff --git a/src/flask/cli.py b/src/flask/cli.py\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -9,7 +9,7 @@\n import traceback\n import typing as t\n from functools import update_wrapper\n-from operator import attrgetter\n+from operator import itemgetter\n \n import click\n from click.core import ParameterSource\n@@ -989,49 +989,62 @@ def shell_command() -> None:\n @click.option(\n     \"--sort\",\n     \"-s\",\n-    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n+    type=click.Choice((\"endpoint\", \"methods\", \"domain\", \"rule\", \"match\")),\n     default=\"endpoint\",\n     help=(\n-        'Method to sort routes by. \"match\" is the order that Flask will match '\n-        \"routes when dispatching a request.\"\n+        \"Method to sort routes by. 'match' is the order that Flask will match routes\"\n+        \" when dispatching a request.\"\n     ),\n )\n @click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n @with_appcontext\n def routes_command(sort: str, all_methods: bool) -> None:\n     \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n-\n     rules = list(current_app.url_map.iter_rules())\n+\n     if not rules:\n         click.echo(\"No routes were registered.\")\n         return\n \n-    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+    host_matching = current_app.url_map.host_matching\n+    has_domain = any(rule.host if host_matching else rule.subdomain for rule in rules)\n+    rows = []\n \n-    if sort in (\"endpoint\", \"rule\"):\n-        rules = sorted(rules, key=attrgetter(sort))\n-    elif sort == \"methods\":\n-        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+    for rule in rules:\n+        row = [\n+            rule.endpoint,\n+            \", \".join(sorted((rule.methods or set()) - ignored_methods)),\n+        ]\n \n-    rule_methods = [\n-        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n-        for rule in rules\n-    ]\n+        if has_domain:\n+            row.append((rule.host if host_matching else rule.subdomain) or \"\")\n \n-    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n-    widths = (\n-        max(len(rule.endpoint) for rule in rules),\n-        max(len(methods) for methods in rule_methods),\n-        max(len(rule.rule) for rule in rules),\n-    )\n-    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n-    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n+        row.append(rule.rule)\n+        rows.append(row)\n+\n+    headers = [\"Endpoint\", \"Methods\"]\n+    sorts = [\"endpoint\", \"methods\"]\n+\n+    if has_domain:\n+        headers.append(\"Host\" if host_matching else \"Subdomain\")\n+        sorts.append(\"domain\")\n+\n+    headers.append(\"Rule\")\n+    sorts.append(\"rule\")\n+\n+    try:\n+        rows.sort(key=itemgetter(sorts.index(sort)))\n+    except ValueError:\n+        pass\n \n-    click.echo(row.format(*headers).strip())\n-    click.echo(row.format(*(\"-\" * width for width in widths)))\n+    rows.insert(0, headers)\n+    widths = [max(len(row[i]) for row in rows) for i in range(len(headers))]\n+    rows.insert(1, [\"-\" * w for w in widths])\n+    template = \"  \".join(f\"{{{i}:<{w}}}\" for i, w in enumerate(widths))\n \n-    for rule, methods in zip(rules, rule_methods):\n-        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n+    for row in rows:\n+        click.echo(template.format(*row))\n \n \n cli = FlaskGroup(\n",
        "test_patch": "diff --git a/tests/test_cli.py b/tests/test_cli.py\n--- a/tests/test_cli.py\n+++ b/tests/test_cli.py\n@@ -433,16 +433,12 @@ class TestRoutes:\n     @pytest.fixture\n     def app(self):\n         app = Flask(__name__)\n-        app.testing = True\n-\n-        @app.route(\"/get_post/<int:x>/<int:y>\", methods=[\"GET\", \"POST\"])\n-        def yyy_get_post(x, y):\n-            pass\n-\n-        @app.route(\"/zzz_post\", methods=[\"POST\"])\n-        def aaa_post():\n-            pass\n-\n+        app.add_url_rule(\n+            \"/get_post/<int:x>/<int:y>\",\n+            methods=[\"GET\", \"POST\"],\n+            endpoint=\"yyy_get_post\",\n+        )\n+        app.add_url_rule(\"/zzz_post\", methods=[\"POST\"], endpoint=\"aaa_post\")\n         return app\n \n     @pytest.fixture\n@@ -450,17 +446,6 @@ def invoke(self, app, runner):\n         cli = FlaskGroup(create_app=lambda: app)\n         return partial(runner.invoke, cli)\n \n-    @pytest.fixture\n-    def invoke_no_routes(self, runner):\n-        def create_app():\n-            app = Flask(__name__, static_folder=None)\n-            app.testing = True\n-\n-            return app\n-\n-        cli = FlaskGroup(create_app=create_app)\n-        return partial(runner.invoke, cli)\n-\n     def expect_order(self, order, output):\n         # skip the header and match the start of each row\n         for expect, line in zip(order, output.splitlines()[2:]):\n@@ -493,11 +478,31 @@ def test_all_methods(self, invoke):\n         output = invoke([\"routes\", \"--all-methods\"]).output\n         assert \"GET, HEAD, OPTIONS, POST\" in output\n \n-    def test_no_routes(self, invoke_no_routes):\n-        result = invoke_no_routes([\"routes\"])\n+    def test_no_routes(self, runner):\n+        app = Flask(__name__, static_folder=None)\n+        cli = FlaskGroup(create_app=lambda: app)\n+        result = runner.invoke(cli, [\"routes\"])\n         assert result.exit_code == 0\n         assert \"No routes were registered.\" in result.output\n \n+    def test_subdomain(self, runner):\n+        app = Flask(__name__, static_folder=None)\n+        app.add_url_rule(\"/a\", subdomain=\"a\", endpoint=\"a\")\n+        app.add_url_rule(\"/b\", subdomain=\"b\", endpoint=\"b\")\n+        cli = FlaskGroup(create_app=lambda: app)\n+        result = runner.invoke(cli, [\"routes\"])\n+        assert result.exit_code == 0\n+        assert \"Subdomain\" in result.output\n+\n+    def test_host(self, runner):\n+        app = Flask(__name__, static_folder=None, host_matching=True)\n+        app.add_url_rule(\"/a\", host=\"a\", endpoint=\"a\")\n+        app.add_url_rule(\"/b\", host=\"b\", endpoint=\"b\")\n+        cli = FlaskGroup(create_app=lambda: app)\n+        result = runner.invoke(cli, [\"routes\"])\n+        assert result.exit_code == 0\n+        assert \"Host\" in result.output\n+\n \n def dotenv_not_available():\n     try:\n",
        "problem_statement": "Flask routes to return domain/sub-domains information\nCurrently when checking **flask routes** it provides all routes but **it is no way to see which routes are assigned to which subdomain**.\r\n\r\n**Default server name:**\r\nSERVER_NAME: 'test.local'\r\n\r\n**Domains (sub-domains):**\r\ntest.test.local\r\nadmin.test.local\r\ntest.local\r\n\r\n**Adding blueprints:**\r\napp.register_blueprint(admin_blueprint,url_prefix='',subdomain='admin')\r\napp.register_blueprint(test_subdomain_blueprint,url_prefix='',subdomain='test')\r\n\r\n\r\n```\r\n$ flask routes\r\n * Tip: There are .env or .flaskenv files present. Do \"pip install python-dotenv\" to use them.\r\nEndpoint                                                 Methods    Rule\r\n-------------------------------------------------------  ---------  ------------------------------------------------\r\nadmin_blueprint.home                                      GET        /home\r\ntest_subdomain_blueprint.home                             GET        /home\r\nstatic                                                    GET        /static/<path:filename>\r\n...\r\n```\r\n\r\n\r\n**Feature request**\r\nIt will be good to see something like below (that will make more clear which route for which subdomain, because now need to go and check configuration).\r\n**If it is not possible to fix routes**, can you add or tell which method(s) should be used to get below information from flask? \r\n\r\n```\r\n$ flask routes\r\n * Tip: There are .env or .flaskenv files present. Do \"pip install python-dotenv\" to use them.\r\nDomain                Endpoint                                             Methods    Rule\r\n-----------------   ----------------------------------------------------  ----------  ------------------------------------------------\r\nadmin.test.local     admin_blueprint.home                                  GET        /home\r\ntest.test.local      test_subdomain_blueprint.home                         GET        /home\r\ntest.local           static                                                GET        /static/<path:filename>\r\n...\r\n```\r\n\n",
        "hints_text": "",
        "created_at": "2023-04-14T16:36:54Z",
        "version": "2.3",
        "FAIL_TO_PASS": "[\"tests/test_cli.py::TestRoutes::test_subdomain\", \"tests/test_cli.py::TestRoutes::test_host\"]",
        "PASS_TO_PASS": "[\"tests/test_cli.py::test_cli_name\", \"tests/test_cli.py::test_find_best_app\", \"tests/test_cli.py::test_prepare_import[test-path0-test]\", \"tests/test_cli.py::test_prepare_import[test.py-path1-test]\", \"tests/test_cli.py::test_prepare_import[a/test-path2-test]\", \"tests/test_cli.py::test_prepare_import[test/__init__.py-path3-test]\", \"tests/test_cli.py::test_prepare_import[test/__init__-path4-test]\", \"tests/test_cli.py::test_prepare_import[value5-path5-cliapp.inner1]\", \"tests/test_cli.py::test_prepare_import[value6-path6-cliapp.inner1.inner2]\", \"tests/test_cli.py::test_prepare_import[test.a.b-path7-test.a.b]\", \"tests/test_cli.py::test_prepare_import[value8-path8-cliapp.app]\", \"tests/test_cli.py::test_prepare_import[value9-path9-cliapp.message.txt]\", \"tests/test_cli.py::test_locate_app[cliapp.app-None-testapp]\", \"tests/test_cli.py::test_locate_app[cliapp.app-testapp-testapp]\", \"tests/test_cli.py::test_locate_app[cliapp.factory-None-app]\", \"tests/test_cli.py::test_locate_app[cliapp.factory-create_app-app]\", \"tests/test_cli.py::test_locate_app[cliapp.factory-create_app()-app]\", \"tests/test_cli.py::test_locate_app[cliapp.factory-create_app2(\\\"foo\\\",\", \"tests/test_cli.py::test_locate_app[cliapp.factory-\", \"tests/test_cli.py::test_locate_app_raises[notanapp.py-None]\", \"tests/test_cli.py::test_locate_app_raises[cliapp/app-None]\", \"tests/test_cli.py::test_locate_app_raises[cliapp.app-notanapp]\", \"tests/test_cli.py::test_locate_app_raises[cliapp.factory-create_app2(\\\"foo\\\")]\", \"tests/test_cli.py::test_locate_app_raises[cliapp.factory-create_app(]\", \"tests/test_cli.py::test_locate_app_raises[cliapp.factory-no_app]\", \"tests/test_cli.py::test_locate_app_raises[cliapp.importerrorapp-None]\", \"tests/test_cli.py::test_locate_app_raises[cliapp.message.txt-None]\", \"tests/test_cli.py::test_locate_app_suppress_raise\", \"tests/test_cli.py::test_get_version\", \"tests/test_cli.py::test_scriptinfo\", \"tests/test_cli.py::test_app_cli_has_app_context\", \"tests/test_cli.py::test_with_appcontext\", \"tests/test_cli.py::test_appgroup_app_context\", \"tests/test_cli.py::test_flaskgroup_app_context\", \"tests/test_cli.py::test_flaskgroup_debug[True]\", \"tests/test_cli.py::test_flaskgroup_debug[False]\", \"tests/test_cli.py::test_flaskgroup_nested\", \"tests/test_cli.py::test_no_command_echo_loading_error\", \"tests/test_cli.py::test_help_echo_loading_error\", \"tests/test_cli.py::test_help_echo_exception\", \"tests/test_cli.py::TestRoutes::test_simple\", \"tests/test_cli.py::TestRoutes::test_sort\", \"tests/test_cli.py::TestRoutes::test_all_methods\", \"tests/test_cli.py::TestRoutes::test_no_routes\", \"tests/test_cli.py::test_load_dotenv\", \"tests/test_cli.py::test_dotenv_path\", \"tests/test_cli.py::test_dotenv_optional\", \"tests/test_cli.py::test_disable_dotenv_from_env\", \"tests/test_cli.py::test_run_cert_path\", \"tests/test_cli.py::test_run_cert_adhoc\", \"tests/test_cli.py::test_run_cert_import\", \"tests/test_cli.py::test_run_cert_no_ssl\", \"tests/test_cli.py::test_cli_blueprints\", \"tests/test_cli.py::test_cli_empty\"]",
        "environment_setup_commit": "182ce3dd15dfa3537391c3efaf9c3ff407d134d4",
        "issue_title": "Flask routes to return domain/sub-domains information",
        "test_file": "/home/fdse/wy/RepoCodeEdit/data/raw_repo_lite/flask/tests/test_apps/subdomaintestmodule/__init__.py",
        "searched_functions": [],
        "imports_info": [
            "from flask import Module"
        ],
        "generated_tests": [
            "from flask import Flask, Blueprint\nimport unittest\n\nclass TestFlaskRoutes(unittest.TestCase):\n    def setUp(self):\n        self.app = Flask(__name__)\n        self.app.config['SERVER_NAME'] = 'test.local'\n        self.admin_blueprint = Blueprint('admin', __name__, subdomain='admin')\n        self.test_subdomain_blueprint = Blueprint('test', __name__, subdomain='test')\n\n    def test_routes_include_subdomain(self):\n        self.app.register_blueprint(self.admin_blueprint)\n        self.app.register_blueprint(self.test_subdomain_blueprint)\n\n        with self.app.app_context():\n            routes = [str(rule) for rule in self.app.url_map.iter_rules()]\n\n        self.assertIn('admin.test.local', routes)\n        self.assertIn('test.test.local', routes)\n\nif __name__ == '__main__':\n    unittest.main()",
            "from flask import Flask, Blueprint\nimport unittest\n\nclass TestFlaskRoutes(unittest.TestCase):\n    def setUp(self):\n        self.app = Flask(__name__)\n        self.app.config['SERVER_NAME'] = 'test.local'\n        self.admin_blueprint = Blueprint('admin', __name__, subdomain='admin')\n        self.test_subdomain_blueprint = Blueprint('test', __name__, subdomain='test')\n\n        @self.admin_blueprint.route('/home')\n        def admin_home():\n            return 'Admin Home'\n\n        @self.test_subdomain_blueprint.route('/home')\n        def test_home():\n            return 'Test Home'\n\n        self.app.register_blueprint(self.admin_blueprint)\n        self.app.register_blueprint(self.test_subdomain_blueprint)\n\n    def test_routes_subdomain(self):\n        with self.app.app_context():\n            routes = [str(rule) for rule in self.app.url_map.iter_rules()]\n            self.assertIn('admin.test.local/home', routes)\n            self.assertIn('test.test.local/home', routes)\n\nif __name__ == '__main__':\n    unittest.main()",
            "from flask import Flask\nimport unittest\n\nclass TestFlaskRoutes(unittest.TestCase):\n    def setUp(self):\n        self.app = Flask(__name__)\n        self.app.config['SERVER_NAME'] = 'test.local'\n        self.client = self.app.test_client()\n\n    def test_routes(self):\n        with self.app.app_context():\n            from flask import url_for\n            self.app.register_blueprint(admin_blueprint, url_prefix='', subdomain='admin')\n            self.app.register_blueprint(test_subdomain_blueprint, url_prefix='', subdomain='test')\n\n            admin_url = url_for('admin_blueprint.home', _external=True)\n            test_url = url_for('test_subdomain_blueprint.home', _external=True)\n\n            self.assertEqual(admin_url, 'http://admin.test.local/home')\n            self.assertEqual(test_url, 'http://test.test.local/home')\n\nif __name__ == '__main__':\n    unittest.main()",
            "from flask import Flask, Blueprint\nimport unittest\n\nclass TestFlaskRoutes(unittest.TestCase):\n    def setUp(self):\n        self.app = Flask(__name__)\n        self.app.config['SERVER_NAME'] = 'test.local'\n        self.admin_blueprint = Blueprint('admin', __name__, subdomain='admin')\n        self.test_subdomain_blueprint = Blueprint('test', __name__, subdomain='test')\n\n        @self.admin_blueprint.route('/home')\n        def admin_home():\n            return 'Admin Home'\n\n        @self.test_subdomain_blueprint.route('/home')\n        def test_home():\n            return 'Test Home'\n\n        self.app.register_blueprint(self.admin_blueprint)\n        self.app.register_blueprint(self.test_subdomain_blueprint)\n\n    def test_routes_output(self):\n        with self.app.app_context():\n            output = self.app.url_map\n            self.assertIn('admin.test.local', str(output))\n            self.assertIn('test.test.local', str(output))\n\nif __name__ == '__main__':\n    unittest.main()",
            "from flask import Flask, Blueprint\nimport unittest\n\nclass TestFlaskRoutes(unittest.TestCase):\n    def setUp(self):\n        self.app = Flask(__name__)\n        self.app.config['SERVER_NAME'] = 'test.local'\n        self.admin_blueprint = Blueprint('admin', __name__, subdomain='admin')\n        self.test_subdomain_blueprint = Blueprint('test', __name__, subdomain='test')\n\n    def test_routes_display_subdomain(self):\n        self.app.register_blueprint(self.admin_blueprint, url_prefix='')\n        self.app.register_blueprint(self.test_subdomain_blueprint, url_prefix='')\n\n        with self.app.app_context():\n            routes = []\n            for rule in self.app.url_map.iter_rules():\n                routes.append({\n                    'Domain': rule.host,\n                    'Endpoint': rule.endpoint,\n                    'Methods': ', '.join(sorted(rule.methods)),\n                    'Rule': rule.rule\n                })\n\n            self.assertIn({\n                'Domain': 'admin.test.local',\n                'Endpoint': 'admin',\n                'Methods': 'GET, HEAD, OPTIONS',\n                'Rule': '/'\n            }, routes)\n\n            self.assertIn({\n                'Domain': 'test.test.local',\n                'Endpoint': 'test',\n                'Methods': 'GET, HEAD, OPTIONS',\n                'Rule': '/'\n            }, routes)\n\nif __name__ == '__main__':\n    unittest.main()"
        ]
    },
    {
        "repo": "pallets/flask",
        "instance_id": "pallets__flask-4992",
        "base_commit": "4c288bc97ea371817199908d0d9b12de9dae327e",
        "patch": "diff --git a/src/flask/config.py b/src/flask/config.py\n--- a/src/flask/config.py\n+++ b/src/flask/config.py\n@@ -234,6 +234,7 @@ def from_file(\n         filename: str,\n         load: t.Callable[[t.IO[t.Any]], t.Mapping],\n         silent: bool = False,\n+        text: bool = True,\n     ) -> bool:\n         \"\"\"Update the values in the config from a file that is loaded\n         using the ``load`` parameter. The loaded data is passed to the\n@@ -244,8 +245,8 @@ def from_file(\n             import json\n             app.config.from_file(\"config.json\", load=json.load)\n \n-            import toml\n-            app.config.from_file(\"config.toml\", load=toml.load)\n+            import tomllib\n+            app.config.from_file(\"config.toml\", load=tomllib.load, text=False)\n \n         :param filename: The path to the data file. This can be an\n             absolute path or relative to the config root path.\n@@ -254,14 +255,18 @@ def from_file(\n         :type load: ``Callable[[Reader], Mapping]`` where ``Reader``\n             implements a ``read`` method.\n         :param silent: Ignore the file if it doesn't exist.\n+        :param text: Open the file in text or binary mode.\n         :return: ``True`` if the file was loaded successfully.\n \n+        .. versionchanged:: 2.3\n+            The ``text`` parameter was added.\n+\n         .. versionadded:: 2.0\n         \"\"\"\n         filename = os.path.join(self.root_path, filename)\n \n         try:\n-            with open(filename) as f:\n+            with open(filename, \"r\" if text else \"rb\") as f:\n                 obj = load(f)\n         except OSError as e:\n             if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n",
        "test_patch": "diff --git a/tests/static/config.toml b/tests/static/config.toml\nnew file mode 100644\n--- /dev/null\n+++ b/tests/static/config.toml\n@@ -0,0 +1,2 @@\n+TEST_KEY=\"foo\"\n+SECRET_KEY=\"config\"\ndiff --git a/tests/test_config.py b/tests/test_config.py\n--- a/tests/test_config.py\n+++ b/tests/test_config.py\n@@ -6,7 +6,6 @@\n \n import flask\n \n-\n # config keys used for the TestConfig\n TEST_KEY = \"foo\"\n SECRET_KEY = \"config\"\n@@ -30,13 +29,23 @@ def test_config_from_object():\n     common_object_test(app)\n \n \n-def test_config_from_file():\n+def test_config_from_file_json():\n     app = flask.Flask(__name__)\n     current_dir = os.path.dirname(os.path.abspath(__file__))\n     app.config.from_file(os.path.join(current_dir, \"static\", \"config.json\"), json.load)\n     common_object_test(app)\n \n \n+def test_config_from_file_toml():\n+    tomllib = pytest.importorskip(\"tomllib\", reason=\"tomllib added in 3.11\")\n+    app = flask.Flask(__name__)\n+    current_dir = os.path.dirname(os.path.abspath(__file__))\n+    app.config.from_file(\n+        os.path.join(current_dir, \"static\", \"config.toml\"), tomllib.load, text=False\n+    )\n+    common_object_test(app)\n+\n+\n def test_from_prefixed_env(monkeypatch):\n     monkeypatch.setenv(\"FLASK_STRING\", \"value\")\n     monkeypatch.setenv(\"FLASK_BOOL\", \"true\")\n",
        "problem_statement": "Add a file mode parameter to flask.Config.from_file()\nPython 3.11 introduced native TOML support with the `tomllib` package. This could work nicely with the `flask.Config.from_file()` method as an easy way to load TOML config files:\r\n\r\n```python\r\napp.config.from_file(\"config.toml\", tomllib.load)\r\n```\r\n\r\nHowever, `tomllib.load()` takes an object readable in binary mode, while `flask.Config.from_file()` opens a file in text mode, resulting in this error:\r\n\r\n```\r\nTypeError: File must be opened in binary mode, e.g. use `open('foo.toml', 'rb')`\r\n```\r\n\r\nWe can get around this with a more verbose expression, like loading from a file opened with the built-in `open()` function and passing the `dict` to `app.Config.from_mapping()`:\r\n\r\n```python\r\n# We have to repeat the path joining that from_file() does\r\nwith open(os.path.join(app.config.root_path, \"config.toml\"), \"rb\") as file:\r\n    app.config.from_mapping(tomllib.load(file))\r\n```\r\n\r\nBut adding a file mode parameter to `flask.Config.from_file()` would enable the use of a simpler expression. E.g.:\r\n\r\n```python\r\napp.config.from_file(\"config.toml\", tomllib.load, mode=\"b\")\r\n```\r\n\n",
        "hints_text": "You can also use:\r\n\r\n```python\r\napp.config.from_file(\"config.toml\", lambda f: tomllib.load(f.buffer))\r\n```\nThanks - I was looking for another way to do it. I'm happy with that for now, although it's worth noting this about `io.TextIOBase.buffer` from the docs:\r\n\r\n> This is not part of the [TextIOBase](https://docs.python.org/3/library/io.html#io.TextIOBase) API and may not exist in some implementations.\nOh, didn't mean for you to close this, that was just a shorter workaround. I think a `text=True` parameter would be better, easier to use `True` or `False` rather than mode strings. Some libraries, like `tomllib`, have _Opinions_ about whether text or bytes are correct for parsing files, and we can accommodate that.\ncan i work on this?\nNo need to ask to work on an issue. As long as the issue is not assigned to anyone and doesn't have have a linked open PR (both can be seen in the sidebar), anyone is welcome to work on any issue.",
        "created_at": "2023-02-22T14:00:17Z",
        "version": "2.3",
        "FAIL_TO_PASS": "[\"tests/test_config.py::test_config_from_file_toml\"]",
        "PASS_TO_PASS": "[\"tests/test_config.py::test_config_from_pyfile\", \"tests/test_config.py::test_config_from_object\", \"tests/test_config.py::test_config_from_file_json\", \"tests/test_config.py::test_from_prefixed_env\", \"tests/test_config.py::test_from_prefixed_env_custom_prefix\", \"tests/test_config.py::test_from_prefixed_env_nested\", \"tests/test_config.py::test_config_from_mapping\", \"tests/test_config.py::test_config_from_class\", \"tests/test_config.py::test_config_from_envvar\", \"tests/test_config.py::test_config_from_envvar_missing\", \"tests/test_config.py::test_config_missing\", \"tests/test_config.py::test_config_missing_file\", \"tests/test_config.py::test_custom_config_class\", \"tests/test_config.py::test_session_lifetime\", \"tests/test_config.py::test_get_namespace\", \"tests/test_config.py::test_from_pyfile_weird_encoding[utf-8]\", \"tests/test_config.py::test_from_pyfile_weird_encoding[iso-8859-15]\", \"tests/test_config.py::test_from_pyfile_weird_encoding[latin-1]\"]",
        "environment_setup_commit": "182ce3dd15dfa3537391c3efaf9c3ff407d134d4",
        "issue_title": "Add a file mode parameter to flask.Config.from_file()",
        "test_file": "/home/fdse/wy/RepoCodeEdit/data/raw_repo_lite/flask/tests/test_config.py",
        "searched_functions": [
            "def test_config_from_file():\n    app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_file(os.path.join(current_dir, \"static\", \"config.json\"), json.load)\n    common_object_test(app)",
            "def test_config_from_pyfile():\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(f\"{__file__.rsplit('.', 1)[0]}.py\")\n    common_object_test(app)",
            "def test_config_missing_file():\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_file(\"missing.json\", load=json.load)\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.json'\")\n    assert not app.config.from_file(\"missing.json\", load=json.load, silent=True)",
            "def test_custom_config_class():\n    class Config(flask.Config):\n        pass\n\n    class Flask(flask.Flask):\n        config_class = Config\n\n    app = Flask(__name__)\n    assert isinstance(app.config, Config)\n    app.config.from_object(__name__)\n    common_object_test(app)",
            "def test_config_missing():\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_pyfile(\"missing.cfg\")\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.cfg'\")\n    assert not app.config.from_pyfile(\"missing.cfg\", silent=True)",
            "def test_config_from_mapping():\n    app = flask.Flask(__name__)\n    app.config.from_mapping({\"SECRET_KEY\": \"config\", \"TEST_KEY\": \"foo\"})\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping([(\"SECRET_KEY\", \"config\"), (\"TEST_KEY\", \"foo\")])\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\", skip_key=\"skip\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        app.config.from_mapping({}, {})",
            "def test_config_from_object():\n    app = flask.Flask(__name__)\n    app.config.from_object(__name__)\n    common_object_test(app)",
            "def test_from_pyfile_weird_encoding(tmpdir, encoding):\n    f = tmpdir.join(\"my_config.py\")\n    f.write_binary(\n        textwrap.dedent(\n            f\"\"\"\n            # -*- coding: {encoding} -*-\n            TEST_VALUE = \"f\u00f6\u00f6\"\n            \"\"\"\n        ).encode(encoding)\n    )\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(str(f))\n    value = app.config[\"TEST_VALUE\"]\n    assert value == \"f\u00f6\u00f6\"",
            "def test_config_from_class():\n    class Base:\n        TEST_KEY = \"foo\"\n\n    class Test(Base):\n        SECRET_KEY = \"config\"\n\n    app = flask.Flask(__name__)\n    app.config.from_object(Test)\n    common_object_test(app)",
            "def test_config_from_envvar_missing(monkeypatch):\n    monkeypatch.setattr(\"os.environ\", {\"FOO_SETTINGS\": \"missing.cfg\"})\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_envvar(\"FOO_SETTINGS\")\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.cfg'\")\n    assert not app.config.from_envvar(\"FOO_SETTINGS\", silent=True)"
        ],
        "imports_info": [
            "import json",
            "import os",
            "import textwrap",
            "import pytest",
            "import flask"
        ],
        "generated_tests": [
            "import os\nimport flask\nimport tomllib\nimport pytest\n\nclass TestConfigFromFile:\n    def test_config_from_toml_file(self):\n        # Create a Flask app\n        app = flask.Flask(__name__)\n\n        # Create a TOML config file\n        config_file_path = os.path.join(app.config.root_path, \"config.toml\")\n        with open(config_file_path, \"w\") as file:\n            file.write(\"\"\"\n            [app]\n            debug = true\n            \"\"\")\n\n        # Load the config file\n        try:\n            app.config.from_file(\"config.toml\", tomllib.load, mode=\"b\")\n        except TypeError as e:\n            pytest.fail(f\"Loading config from TOML file failed with error: {e}\")\n\n        # Check that the configuration was correctly applied\n        assert app.config[\"DEBUG\"] == True, \"Configuration not correctly applied from TOML file\"",
            "import os\nimport flask\nimport tomllib\nimport pytest\n\nclass TestFlaskConfig:\n    def test_config_from_toml_file(self):\n        app = flask.Flask(__name__)\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        config_file = os.path.join(current_dir, \"config.toml\")\n\n        # Create a TOML config file\n        with open(config_file, 'wb') as file:\n            file.write(b'[database]\\nserver = \"192.168.1.1\"\\nports = [ 8001, 8001, 8002 ]\\nconnection_max = 5000\\nenabled = true')\n\n        # Load the config file\n        try:\n            app.config.from_file(config_file, tomllib.load, mode=\"b\")\n        except TypeError as e:\n            pytest.fail(f\"Loading TOML config file failed with error: {str(e)}\")\n\n        # Check if the config was loaded correctly\n        assert app.config['database']['server'] == \"192.168.1.1\"\n        assert app.config['database']['ports'] == [8001, 8001, 8002]\n        assert app.config['database']['connection_max'] == 5000\n        assert app.config['database']['enabled'] == True",
            "import os\nimport flask\nimport tomllib\nimport pytest\n\nclass TestFlaskConfigFromFile:\n    def test_config_from_toml_file(self):\n        app = flask.Flask(__name__)\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        config_file_path = os.path.join(current_dir, \"config.toml\")\n\n        # Create a TOML config file\n        with open(config_file_path, \"w\") as file:\n            file.write(\"[app]\\nname = 'test_app'\")\n\n        try:\n            # Try to load the config file in binary mode\n            app.config.from_file(config_file_path, tomllib.load, mode=\"b\")\n        except TypeError as e:\n            pytest.fail(f\"Loading config from TOML file failed with TypeError: {e}\")\n\n        # Assert that the config was loaded correctly\n        assert app.config[\"app\"][\"name\"] == \"test_app\"",
            "import os\nimport flask\nimport tomllib\nimport pytest\n\nclass TestFlaskConfigFromFile:\n    def test_config_from_file_with_binary_mode(self):\n        # Create a Flask app\n        app = flask.Flask(__name__)\n\n        # Create a TOML configuration file\n        config_file_path = os.path.join(app.config.root_path, \"config.toml\")\n        with open(config_file_path, \"wb\") as file:\n            file.write(b'[flask]\\nDEBUG = true')\n\n        # Load the configuration file using the from_file() method with binary mode\n        app.config.from_file(\"config.toml\", tomllib.load, mode=\"b\")\n\n        # Check that the configuration was correctly applied\n        assert app.config['DEBUG'] == True\n\n        # Clean up the configuration file\n        os.remove(config_file_path)",
            "import os\nimport flask\nimport tomllib\nimport pytest\n\nclass TestConfigFromFile:\n    def test_load_toml_file_in_binary_mode(self):\n        app = flask.Flask(__name__)\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        toml_file_path = os.path.join(current_dir, \"config.toml\")\n\n        # Create a TOML file for testing\n        with open(toml_file_path, 'wb') as file:\n            file.write(b'[test]\\nkey = \"value\"')\n\n        # Load the TOML file using flask.Config.from_file() with mode=\"b\"\n        app.config.from_file(toml_file_path, tomllib.load, mode=\"b\")\n\n        # Check if the configuration is correctly set\n        assert app.config['test']['key'] == 'value'\n\n        # Clean up the test TOML file\n        os.remove(toml_file_path)"
        ]
    }
]